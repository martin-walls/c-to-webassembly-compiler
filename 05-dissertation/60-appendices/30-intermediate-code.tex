\documentclass[../00-main.tex]{subfiles}

\begin{document}

\chapter{Intermediate Code}\label{app:intermediate code}

This appendix summarises the instructions I created for the \acrlong{ir}.
\IrCode{x} and \IrCode{y} can either be variables or constants, used as operands to instructions.
\IrCode{t} is a destination variable.

\begin{xltabular}{\textwidth}{$l^X}
\caption{\gls{ir} code instructions.} \\
\toprule
\rowstyle{\bfseries}Instruction & Description \\
\midrule
\endfirsthead % chktex 1
\caption[]{\gls{ir} code instructions (continued).} \\
\toprule
\rowstyle{\bfseries}Instruction & Description \\
\midrule
\endhead % chktex 1
% \bottomrule
\endfoot % chktex 1
\IrCode{t = x} & Simple assignment. \\
\midrule
\IrCode{t = load from x} & Load from and store to memory. \\
\IrCode{store x to addr y} &  \\
\midrule
\IrCode{declare var t} & Declare a new variable \IrCode{t}. \\
\IrCode{allocate x bytes for var y} & Allocate memory for \IrCode{y} (used for allocating aggregate data structures, e.g.~arrays). \\
\midrule
\IrCode{reference var x} & A non-executable instruction used internally to mark a variable as live at this program point. \\
\midrule
\IrCode{t = \&x} & Address-of operator. \\
\IrCode{t = \char`\~x} & Bitwise \textsc{not}. \\
\IrCode{t = !x} & Logical \textsc{not}. \\
\midrule
\IrCode{t = x * y} & Multiplication. \\
\IrCode{t = x / y} & Division. \\
\IrCode{t = x \% y} & Modulus. \\
\IrCode{t = x + y} & Addition. \\
\IrCode{t = x - y} & Subtraction. \\
\IrCode{t = x << y} & Left-shift. \\
\IrCode{t = x >> y} & Right-shift (signed-extending for signed \IrCode{x}, zero-filling for unsigned \IrCode{x}). \\
\IrCode{t = x \& y} & Bitwise \textsc{and}. \\
\IrCode{t = x | y} & Bitwise \textsc{or}. \\
\IrCode{t = x \char`\^\ y} & Bitwise \textsc{xor}. \\
\IrCode{t = x \&\& y} & Logical \textsc{and}. \\
\IrCode{t = x || y} & Logical \textsc{or}. \\
\IrCode{t = x < y} & Less-than comparison. \\
\IrCode{t = x > y} & Greater-than comparison. \\
\IrCode{t = x <= y} & Less-than or equal comparison. \\
\IrCode{t = x >= y} & Greater-than or equal comparison. \\
\IrCode{t = x == y} & Equality comparison. \\
\IrCode{t = x != y} & Inequality comparison. \\
\midrule
\IrCode{t = call f(p\textsubscript{1}, p\textsubscript{2}, ...)} & Call function \IrCode{f} with parameters \IrCode{p\textsubscript{i}} (either variables or constants). \\
\IrCode{tail-call f(p\textsubscript{1}, p\textsubscript{2}, ...)} & Call function \IrCode{f} and return the result from the current function. \\
\IrCode{return [x]} & Return from the current function. The return value \IrCode{x} is optional. \\
\midrule
\IrCode{label <l>} & Attach a label to the current program point (immediately before the next instruction). \\
\IrCode{br <l>} & Unconditional branch. \\
\IrCode{br <l> if x == y} & Conditional branch; executed if operands are equal. \\
\IrCode{br <l> if x != y} & Conditional branch; executed if operands are not equal. \\
\midrule
\IrCode{t = \&<sid>} & Static address of the string literal with id <sid>. \\
\midrule
\IrCode{t = (i8 $\to$ i16) x} & Char promotions. \\
\IrCode{t = (i8 $\to$ u16) x} &  \\
\IrCode{t = (u8 $\to$ u16) x} &  \\
\IrCode{t = (u8 $\to$ u16) x} &  \\
\midrule
\IrCode{t = (i16 $\to$ i32) x} & Promotions to signed integer. \\
\IrCode{t = (u16 $\to$ i32) x} &  \\
\midrule
\IrCode{t = (i16 $\to$ u32) x} & Promotions to unsigned integer. \\
\IrCode{t = (u16 $\to$ u32) x} &  \\
\IrCode{t = (i32 $\to$ u32) x} &  \\
\midrule
\IrCode{t = (i32 $\to$ i64) x} & Promotions to signed long. \\
\IrCode{t = (u32 $\to$ i64) x} &  \\
\midrule
\IrCode{t = (i32 $\to$ u64) x} & Promotions to unsigned long. \\
\IrCode{t = (u32 $\to$ u64) x} &  \\
\IrCode{t = (i64 $\to$ u64) x} &  \\
\midrule
\IrCode{t = (u32 $\to$ f32) x} & Integer to float conversions. \\
\IrCode{t = (i32 $\to$ f32) x} & \\
\IrCode{t = (u64 $\to$ f32) x} & \\
\IrCode{t = (i64 $\to$ f32) x} & \\
\midrule
\IrCode{t = (u32 $\to$ f64) x} & Integer to double conversions. \\
\IrCode{t = (i32 $\to$ f64) x} & \\
\IrCode{t = (u64 $\to$ f64) x} & \\
\IrCode{t = (i64 $\to$ f64) x} & \\
\midrule
\IrCode{t = (f32 $\to$ f64) x} & Float to double promotion. \\
\midrule
\IrCode{t = (f64 $\to$ i32) x} & Double to int conversion. \\
\midrule
\IrCode{t = (i32 $\to$ i8) x} & Integer truncation. \\
\IrCode{t = (u32 $\to$ i8) x} & \\
\IrCode{t = (i64 $\to$ i8) x} & \\
\IrCode{t = (u64 $\to$ i8) x} & \\
\IrCode{t = (i32 $\to$ u8) x} & \\
\IrCode{t = (u32 $\to$ u8) x} & \\
\IrCode{t = (i64 $\to$ u8) x} & \\
\IrCode{t = (u64 $\to$ u8) x} & \\
\IrCode{t = (i64 $\to$ i32) x} & \\
\IrCode{t = (u64 $\to$ i32) x} & \\
\midrule
\IrCode{t = (u32 $\to$ *) x} & Conversions between integer and pointer. \\
\IrCode{t = (i32 $\to$ *) x} & \\
\IrCode{t = (* $\to$ i32) x} & \\
\midrule
\IrCode{nop} & No-op. \\
\midrule
\IrCode{break <loop_block_id>} & \multirow[t]{3}{=}{Control-flow instructions inserted by the Relooper algorithm as it processes branch instructions.} \\
\IrCode{continue <loop_block_id>} &  \\
\IrCode{end handled <multiple_block_id>} &  \\
\midrule
\IrCode{if x == y \{\} else \{\}} & \multirow[t]{5}{=}{Conditional control flow instructions with nested instructions for each branch. These are only inserted by the Relooper algorithm, to replace a conditional branch with conditionally setting the label variable and then branching.} \\
\IrCode{if x != y \{\} else \{\}} &  \\
\\\\\\
\bottomrule
\end{xltabular}

\end{document}
