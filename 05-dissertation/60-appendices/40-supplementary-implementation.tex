\documentclass[../00-main.tex]{subfiles}

\begin{document}

\chapter{Supplementary Implementation Details}

\begin{mrwComment}
Add a chapter overview text here
\end{mrwComment}

\section{Parsing String Escape Sequences}

In C, string literals can contain escape sequences, such as \texttt{\char`\\n} to insert a new line character~\ccite[sec.~2.7.5]{c-reference-manual}.
The parser needs to be convert these to the literal characters they represent.
My compiler supports the escape codes described in \ccref{app:tab:supported string escape codes}.

I implemented this by creating an iterator over the characters of the string, that replaces escape sequences as it emits characters (\ccref{app:lst:string escape iterator}).
When the current character is a backslash (`\texttt{\char`\\}'), the next one or more characters form an escape sequence.
The iterator consumes the characters of the escape sequence, and matches it against the valid escape sequences to perform the appropriate character substitution, which is emitted as the next character from the iterator.
When the current character is not a backslash, it is emitted as-is.

I wrapped this in an \RustInline{interpret_string} function that internally creates an instance of the iterator and collects the emitted characters back to a string (\ccref{app:lst:interpret string function}).
I also wrote a set of unit tests to verify the iterator was functioning correctly.

\begin{table}[h]
  \centering
  \begin{tabular}{$l^l}
    \toprule
    \rowstyle{\bfseries}Escape sequence & Represented character \\
    \midrule
    \texttt{\char`\\'} & Single quote \\
    \texttt{\char`\\"} & Double quote \\ % chktex 18
    \texttt{\char`\\?} & Question mark \\ % chktex 18
    \texttt{\char`\\\char`\\} & Backslash \\ % chktex 18
    \texttt{\char`\\n} & New line (line feed) \\ % chktex 18
    \texttt{\char`\\r} & Carriage return \\ % chktex 18
    \texttt{\char`\\t} & Horizontal tab \\ % chktex 18
    \texttt{\char`\\xhh\ldots} & The byte given by \texttt{hh\ldots} interpreted as a hexadecimal number \\ % chktex 18
    \texttt{\char`\\nnn} & The byte given by \texttt{nnn} interpreted as an octal number \\ % chktex 18
    \bottomrule
  \end{tabular}
  \caption{Supported string escape sequences.}%
  \label{app:tab:supported string escape codes}
\end{table}

\begin{listing}[t]
  \begin{RustListing}
    struct InterpretString<'a> {
        s: Peekable<Chars<'a>>,
    }
    impl Iterator for InterpretString<'_> {
        fn next(&mut self) -> Option<Self::Item> {
            match self.s.next() {
                Some(c) => Some(match c {
                    '\\' => match self.s.next() {
                        Some('n') => Ok('\n'),  // New line
                        // \', \", \t, \r, etc.
                        Some('x') => { // Hexadecimal character code
                            // Check whether the next digit is a valid hex digit
                            match self.s.peek() {
                                Some(c) if c.is_ascii_hexdigit() => {
                                    // Store the hex digits in a buffer
                                    let mut buffer = String::new();
                                    // Keep consuming hex digits
                                    while let Some(c) = self.s.next() {
                                        buffer.push(c); // Consume the next hex digit
                                        match self.s.peek() { // Check the following char
                                            Some(c) if c.is_ascii_hexdigit() => continue,
                                            Some(_) | None => break,
                                        }
                                    }
                                    // Convert the hex code to the corresponding char
                                    let hex_code = u32::from_str_radix(&buffer, 16).unwrap();
                                    match char::from_u32(hex_code) {
                                        Some(c) => Ok(c),
                                        None => Err(InvalidCharCode(buffer)),
                                    }
                                }
                                Some(c) => Err(InvalidEscapeChar(*c)),
                                None => Err(EscapeCharAtEndOfString),
                            }
                        }
                        Some(c) if c.is_digit(8) => {} // Octal character code similarly
                        Some(c) => Err(InvalidEscapeChar(c)), // Invalid escape code
                        None => Err(EscapeCharAtEndOfString),
                    },
                    c => Ok(c), // All other (non-escape) characters
                }),
                None => None,
            }
        }
    }
  \end{RustListing}
  \caption{Implementation of an iterator to handle string escape sequences.}
  \label{app:lst:string escape iterator}
\end{listing}

\begin{listing}[t]
  \begin{RustListing}
    pub fn interpret_string(s: &str) -> Result<String, Error> {
        InterpretString::new(s).collect()
    }
  \end{RustListing}
  \caption{Function wrapper around the \RustInline{InterpretString} iterator (see \ccref{app:lst:string escape iterator}).}
  \label{app:lst:interpret string function}
\end{listing}


\section{Parsing Type Specifiers}

Another feature of the C language is that type specifiers (\CInline{int}, \CInline{signed}, etc.) can appear in any order before a declaration.
For example, \CInline{signed int x} and \CInline{int signed x} are equivalent declarations.
To handle this, my parser first consumes all type specifier tokens of a declaration, then constructs an \RustInline{ArithmeticType} \gls{ast} node from them.
It uses a bitfield where each bit represents the presence of one of the type specifiers in the type.
The bitfield is the normalised representation of a type; every possible declaration that is equivalent to a type will have the same bitfield.
The declarations above would construct the bitfield \RustInline{0b00010100}, where the two bits set represent \CInline{signed} and \CInline{int} respectively.
For each type specifier, the corresponding bit is set.
Then, the bitfield is matched against the possible valid types, to assign the type to the \gls{ast} node.

\end{document}
