use crate::ast;

grammar;


pub Identifier: ast::Identifier = r"[a-zA-Z_][a-zA-Z0-9_]*"
  => ast::Identifier(<>.to_owned());

pub Constant: ast::Constant = {
  IntegerConstant => ast::Constant::IntegerConstant(<>),
  DecimalFloatingConstant => ast::Constant::FloatingConstant(<>),
};

pub IntegerConstant: u128 = {
  DecimalConstant,
  BinaryConstant,
  OctalConstant,
  HexadecimalConstant,
}

DecimalConstant: u128 = r"[1-9][0-9]*"
  => u128::from_str_radix(&<>, 10).unwrap();

BinaryConstant: u128 = r"0(b|B)[0-1]+"
  => u128::from_str_radix(&<>[2..], 2).unwrap();

OctalConstant: u128 = r"0[0-7]*"
  => u128::from_str_radix(&<>, 8).unwrap();

HexadecimalConstant: u128 = r"0(x|X)[0-9A-Fa-f]+"
  => u128::from_str_radix(&<>[2..], 16).unwrap();

pub DecimalFloatingConstant: f64 = r"((([0-9]*\.[0-9]+)|([0-9]+\.))((e|E)(\+|-)?[0-9]+)?)|([0-9]+(e|E)(\+|-)?[0-9]+)" => <>.parse::<f64>().unwrap();

// remove leading and trailing double quote using slice
pub StringLiteral: String = r#"".*""# => <>[1..(<>.len()-1)].to_owned();





pub Statement: Box<ast::Statement> = {
  OpenStatement,
  ClosedStatement,
};

OpenStatement: Box<ast::Statement> = {
  "if" "(" <Expression> ")" <Statement> => Box::new(ast::Statement::If(<>)),
  "if" "(" <Expression> ")" <ClosedStatement> "else" <OpenStatement> => Box::new(ast::Statement::IfElse(<>)),
  "while" "(" <Expression> ")" <OpenStatement> => Box::new(ast::Statement::While(<>)),
  "for" "(" <Expression?> ";" <Expression?> ";" <Expression?> ")" <OpenStatement> => Box::new(ast::Statement::For(<>)),
};

ClosedStatement: Box<ast::Statement> = {
  "if" "(" <Expression> ")" <ClosedStatement> "else" <ClosedStatement> => Box::new(ast::Statement::IfElse(<>)),
  "goto" <Identifier> ";" => Box::new(ast::Statement::Goto(<>)),
  "continue" ";" => Box::new(ast::Statement::Continue),
  "break" ";" => Box::new(ast::Statement::Break),
  "return" <Expression?> ";" => Box::new(ast::Statement::Return(<>)),
  "while" "(" <Expression> ")" <ClosedStatement> => Box::new(ast::Statement::While(<>)),
  "do" <Statement> "while" "(" <Expression> ")" ";" => Box::new(ast::Statement::DoWhile(<>)),
  "for" "(" <Expression?> ";" <Expression?> ";" <Expression?> ")" <ClosedStatement> => Box::new(ast::Statement::For(<>)),
  "switch" "(" <Expression> ")" <ClosedStatement> => Box::new(ast::Statement::Switch(<>)),
  Block,
  <Expression> ";" => Box::new(ast::Statement::Expr(<>)),
}

Block: Box<ast::Statement> = "{" <StatementList> "}" => Box::new(ast::Statement::Block(<>));

LabelledStatement: Box<ast::Statement> = {
  "case" ConstantExpression ":" Statement => Box::new(ast::Statement::Labelled(ast::LabelledStatement::Case)),
  "default" ":" Statement => Box::new(ast::Statement::Labelled(ast::LabelledStatement::Default)),
  <Identifier> ":" Statement => Box::new(ast::Statement::Labelled(ast::LabelledStatement::Named(<>))),
}

pub StatementList: Vec<Box<ast::Statement>> = {
  <Statement> => vec![<>],
  <v:StatementList> <s:Statement> => {
    let mut newv = v.to_vec();
    newv.push(s);
    newv
  },
};


ConstantExpression = "";

pub Expression: Box<ast::Expression> = {
  AssignmentExpression,
};

AssignmentExpression: Box<ast::Expression> = {
  ConditionalExpression,
  <UnaryExpression> "=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, None)),
  <UnaryExpression> "*=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, Some(ast::BinaryOperator::Mult))),
  <UnaryExpression> "/=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, Some(ast::BinaryOperator::Div))),
  <UnaryExpression> "%=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, Some(ast::BinaryOperator::Mod))),
  <UnaryExpression> "+=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, Some(ast::BinaryOperator::Add))),
  <UnaryExpression> "-=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, Some(ast::BinaryOperator::Sub))),
  <UnaryExpression> "<<=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, Some(ast::BinaryOperator::LeftShift))),
  <UnaryExpression> ">>=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, Some(ast::BinaryOperator::RightShift))),
  <UnaryExpression> "&=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, Some(ast::BinaryOperator::BitwiseAnd))),
  <UnaryExpression> "^=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, Some(ast::BinaryOperator::BitwiseXor))),
  <UnaryExpression> "|=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, Some(ast::BinaryOperator::BitwiseOr))),
}

ConditionalExpression: Box<ast::Expression> = {
  LogicalOrExpression,
  <LogicalOrExpression> "?" <Expression> ":" <ConditionalExpression>
    => Box::new(ast::Expression::Ternary(<>)),
};

LogicalOrExpression: Box<ast::Expression> = {
  LogicalAndExpression,
  <LogicalOrExpression> "||" <LogicalAndExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::LogicalOr, <>)),
};

LogicalAndExpression: Box<ast::Expression> = {
  InclusiveOrExpression,
  <LogicalAndExpression> "&&" <InclusiveOrExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::LogicalAnd, <>)),
};

InclusiveOrExpression: Box<ast::Expression> = {
  ExclusiveOrExpression,
  <InclusiveOrExpression> "|" <ExclusiveOrExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::BitwiseOr, <>)),
};

ExclusiveOrExpression: Box<ast::Expression> = {
  AndExpression,
  <ExclusiveOrExpression> "^" <AndExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::BitwiseXor, <>)),
};

AndExpression: Box<ast::Expression> = {
  EqualityExpression,
  <AndExpression> "&" <EqualityExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::BitwiseAnd, <>)),
};

EqualityExpression: Box<ast::Expression> = {
  RelationalExpression,
  <EqualityExpression> "==" <RelationalExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::Equal, <>)),
  <EqualityExpression> "!=" <RelationalExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::NotEqual, <>)),
};

RelationalExpression: Box<ast::Expression> = {
  ShiftExpression,
  <RelationalExpression> "<" <ShiftExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::LessThan, <>)),
  <RelationalExpression> ">" <ShiftExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::GreaterThan, <>)),
  <RelationalExpression> "<=" <ShiftExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::LessThanEq, <>)),
  <RelationalExpression> ">=" <ShiftExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::GreaterThanEq, <>)),
};

ShiftExpression: Box<ast::Expression> = {
  AdditiveExpression,
  <ShiftExpression> "<<" <AdditiveExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::LeftShift, <>)),
  <ShiftExpression> ">>" <AdditiveExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::RightShift, <>)),
};

AdditiveExpression: Box<ast::Expression> = {
  MultiplicativeExpression,
  <AdditiveExpression> "+" <MultiplicativeExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::Add, <>)),
  <AdditiveExpression> "-" <MultiplicativeExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::Sub, <>)),
};

MultiplicativeExpression: Box<ast::Expression> = {
  CastExpression,
  <MultiplicativeExpression> "*" <CastExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::Mult, <>)),
  <MultiplicativeExpression> "/" <CastExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::Div, <>)),
  <MultiplicativeExpression> "%" <CastExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::Mod, <>)),
};

CastExpression: Box<ast::Expression> = {
  UnaryExpression,
  "(" <TypeSpecifier> ")" <CastExpression> => Box::new(ast::Expression::Cast(<>)),
};



TypeSpecifier: ast::TypeSpecifier = {
  CharType,
  ShortType,
  IntType,
  LongType,
  "void" => ast::TypeSpecifier::Void,  
  "float" => ast::TypeSpecifier::F32,
  "double" => ast::TypeSpecifier::F64,
  "_Bool" => ast::TypeSpecifier::Bool,
  "struct" <Identifier> => ast::TypeSpecifier::Struct(<>),
  "union" <Identifier> => ast::TypeSpecifier::Union(<>),
}

CharType: ast::TypeSpecifier = {
  // implementation defined, make char signed by default, same as gcc
  "char" => ast::TypeSpecifier::I8,
  "signed" "char" => ast::TypeSpecifier::I8,
  "unsigned" "char" => ast::TypeSpecifier::U8,
};

ShortType: ast::TypeSpecifier = {
  "short" => ast::TypeSpecifier::I16,
  "short" "int" => ast::TypeSpecifier::I16,
  "signed" "short" => ast::TypeSpecifier::I16,
  "signed" "short" "int" => ast::TypeSpecifier::I16,
  "unsigned" "short" => ast::TypeSpecifier::U16,
  "unsigned" "short" "int" => ast::TypeSpecifier::U16,
}

IntType: ast::TypeSpecifier = {
  "int" => ast::TypeSpecifier::I32,
  "signed" => ast::TypeSpecifier::I32,
  "signed" "int" => ast::TypeSpecifier::I32,
  "unsigned" "int" => ast::TypeSpecifier::U32,
  "unsigned" => ast::TypeSpecifier::U32,
}

LongType: ast::TypeSpecifier = {
  "long" => ast::TypeSpecifier::I64,
  "long" "int" => ast::TypeSpecifier::I64,
  "signed" "long" => ast::TypeSpecifier::I64,
  "signed" "long" "int" => ast::TypeSpecifier::I64,
  "unsigned" "long" => ast::TypeSpecifier::U64,
  "unsigned" "long" "int" => ast::TypeSpecifier::U64,
};



UnaryExpression = {
  PostfixExpression,
  "++" <UnaryExpression> => Box::new(ast::Expression::PrefixIncrement(<>)),
  "--" <UnaryExpression> => Box::new(ast::Expression::PrefixDecrement(<>)),
  <UnaryOperator> <CastExpression> => Box::new(ast::Expression::UnaryOp(<>)),
};

UnaryOperator: ast::UnaryOperator = {
  "&" => ast::UnaryOperator::AddressOf,
  "*" => ast::UnaryOperator::Dereference,
  "+" => ast::UnaryOperator::Plus,
  "-" => ast::UnaryOperator::Minus,
  "~" => ast::UnaryOperator::BitwiseNot,
  "!" => ast::UnaryOperator::LogicalNot,
  "sizeof" => ast::UnaryOperator::SizeOf,
};

PostfixExpression: Box<ast::Expression> = {
  <PrimaryExpression>,
  <PostfixExpression> "[" <Expression> "]" => Box::new(ast::Expression::Index(<>)),
  <PostfixExpression> "(" <ArgumentExpressionList?> ")" => Box::new(ast::Expression::FunctionCall(<>)),
  <PostfixExpression> "." <Identifier> => Box::new(ast::Expression::DirectMemberSelection(<>)),
  <PostfixExpression> "->" <Identifier> => Box::new(ast::Expression::IndirectMemberSelection(<>)),
  <PostfixExpression> "++" => Box::new(ast::Expression::PostfixIncrement(<>)),
  <PostfixExpression> "--" => Box::new(ast::Expression::PostfixDecrement(<>)),
};

ArgumentExpressionList: Vec<Box<ast::Expression>> = {
  <AssignmentExpression> => vec![<>],
  <v:ArgumentExpressionList> "," <e:AssignmentExpression> => {
    let mut newv = v.to_vec();
    newv.push(e);
    newv
  },
};

PrimaryExpression: Box<ast::Expression> = {
  <Identifier> => Box::new(ast::Expression::Identifier(<>)),
  <Constant> => Box::new(ast::Expression::Constant(<>)),
  <StringLiteral> => Box::new(ast::Expression::StringLiteral(<>)),
  "(" <Expression> ")",
};