use crate::parser::ast;

grammar;


// CONSTANTS -------------------------

pub Identifier: ast::Identifier = r"[a-zA-Z_][a-zA-Z0-9_]*"
  => ast::Identifier(<>.to_owned());

pub Constant: ast::Constant = {
  IntegerConstant => ast::Constant::Int(<>),
  DecimalFloatingConstant => ast::Constant::Float(<>),
};

IntegerConstant: u128 = {
  DecimalConstant,
  BinaryConstant,
  OctalConstant,
  HexadecimalConstant,
}

DecimalConstant: u128 = r"[1-9][0-9]*"
  => u128::from_str_radix(&<>, 10).unwrap();

BinaryConstant: u128 = r"0(b|B)[0-1]+"
  => u128::from_str_radix(&<>[2..], 2).unwrap();

OctalConstant: u128 = r"0[0-7]*"
  => u128::from_str_radix(&<>, 8).unwrap();

HexadecimalConstant: u128 = r"0(x|X)[0-9A-Fa-f]+"
  => u128::from_str_radix(&<>[2..], 16).unwrap();

DecimalFloatingConstant: f64 = r"((([0-9]*\.[0-9]+)|([0-9]+\.))((e|E)(\+|-)?[0-9]+)?)|([0-9]+(e|E)(\+|-)?[0-9]+)" => <>.parse::<f64>().unwrap();

// remove leading and trailing double quote using slice
pub StringLiteral: String = r#"".*""# => <>[1..(<>.len()-1)].to_owned();



// STATEMENTS -------------------------------

pub Statement: Box<ast::Statement> = {
  OpenStatement,
  ClosedStatement,
};

OpenStatement: Box<ast::Statement> = {
  "if" "(" <Expression> ")" <Statement> => Box::new(ast::Statement::If(<>)),
  "if" "(" <Expression> ")" <ClosedStatement> "else" <OpenStatement> => Box::new(ast::Statement::IfElse(<>)),
  "while" "(" <Expression> ")" <OpenStatement> => Box::new(ast::Statement::While(<>)),
  "for" "(" <Expression?> ";" <Expression?> ";" <Expression?> ")" <OpenStatement> => Box::new(ast::Statement::For(<>)),
};

ClosedStatement: Box<ast::Statement> = {
  "if" "(" <Expression> ")" <ClosedStatement> "else" <ClosedStatement> => Box::new(ast::Statement::IfElse(<>)),
  "goto" <Identifier> ";" => Box::new(ast::Statement::Goto(<>)),
  "continue" ";" => Box::new(ast::Statement::Continue),
  "break" ";" => Box::new(ast::Statement::Break),
  "return" <Expression?> ";" => Box::new(ast::Statement::Return(<>)),
  "while" "(" <Expression> ")" <ClosedStatement> => Box::new(ast::Statement::While(<>)),
  "do" <Statement> "while" "(" <Expression> ")" ";" => Box::new(ast::Statement::DoWhile(<>)),
  "for" "(" <Expression?> ";" <Expression?> ";" <Expression?> ")" <ClosedStatement> => Box::new(ast::Statement::For(<>)),
  "switch" "(" <Expression> ")" <ClosedStatement> => Box::new(ast::Statement::Switch(<>)),
  Block,
  <Expression> ";" => Box::new(ast::Statement::Expr(<>)),
}

Block: Box<ast::Statement> = {
  "{" <StatementList> "}" => Box::new(ast::Statement::Block(<>)),
  "{" "}" => Box::new(ast::Statement::Block(vec![])),
};

LabelledStatement: Box<ast::Statement> = {
  "case" ConditionalExpression ":" Statement => Box::new(ast::Statement::Labelled(ast::LabelledStatement::Case)),
  "default" ":" Statement => Box::new(ast::Statement::Labelled(ast::LabelledStatement::Default)),
  <Identifier> ":" Statement => Box::new(ast::Statement::Labelled(ast::LabelledStatement::Named(<>))),
}

pub StatementList: Vec<Box<ast::Statement>> = {
  <Statement> => vec![<>],
  <v:StatementList> <s:Statement> => {
    let mut newv = v.to_vec();
    newv.push(s);
    newv
  },
};


// DECLARATIONS -----------------------------

pub TypeSpecifier: ast::TypeSpecifier = {
  <ArithmeticType> => ast::TypeSpecifier::ArithmeticType(<>),
  "void" => ast::TypeSpecifier::Void,
  <StructDeclaration> => ast::TypeSpecifier::Struct(<>),
  <UnionDeclaration> => ast::TypeSpecifier::Union(<>),
  <EnumDeclaration>,
};

ArithmeticType: ast::ArithmeticType = {
  <CharType>,
  <IntType> => match <> {
    // bitfield: signed unsigned long int short
    0b00001 | 0b00011 | 0b10001 | 0b10011 => ast::ArithmeticType::I16,
    0b01001 | 0b01011 => ast::ArithmeticType::U16,
    0b00010 | 0b10000 | 0b10010 => ast::ArithmeticType::I32,
    0b01000 | 0b01010 => ast::ArithmeticType::U32,
    0b00100 | 0b00110 | 0b10100 | 0b10110 => ast::ArithmeticType::I64,
    0b01100 | 0b01110 => ast::ArithmeticType::U64,
    _ => panic!("Invalid type specifier"),
  },
  "float" => ast::ArithmeticType::F32,
  "double" => ast::ArithmeticType::F64,
};

CharType: ast::ArithmeticType = {
  "signed" "char" => ast::ArithmeticType::I8,
  "unsigned" "char" => ast::ArithmeticType::U8,
  // implementation defined, make char signed by default, same as gcc
  "char" => ast::ArithmeticType::I8,
};

// bitfield: signed unsigned long int short
IntType: u8 = {
  <IntType?> "short" => match <> {
    Some(n) => n + 1,
    None => 1,
  },
  <IntType?> "int" => match <> {
    Some(n) => n + 2,
    None => 2,
  },
  <IntType?> "long" => match <> {
    Some(n) => n + 4,
    None => 4,
  },
  <IntType?> "unsigned" => match <> {
    Some(n) => n + 8,
    None => 8,
  },
  <IntType?> "signed" => match <> {
    Some(n) => n + 16,
    None => 16,
  },
};

StructDeclaration: ast::StructType = {
  "struct" <Identifier> => ast::StructType::Declaration(<>),
};

UnionDeclaration: ast::UnionType = {
  "union" <Identifier> => ast::UnionType::Declaration(<>),
};

EnumDeclaration: ast::TypeSpecifier = {
  "enum" <Identifier?> "{" <EnumeratorList> ","? "}" => ast::TypeSpecifier::Enum(<>),
};

EnumeratorList: Vec<ast::Enumerator> = {
  <Enumerator> => vec![<>],
  <v:EnumeratorList> "," <e:Enumerator> => {
    let mut newv = v.to_vec();
    newv.push(e);
    newv
  },
};

Enumerator: ast::Enumerator = {
  <Identifier> => ast::Enumerator::Simple(<>),
  <Identifier> "=" <ConstantExpression> => ast::Enumerator::WithValue(<>),
};

// pub Declaration = {
//   DeclarationSpecifiers InitDeclaratorList ";"
// }

// DeclarationSpecifiers = {
//   <StorageClassSpecifier> <DeclarationSpecifiers?>,
//   <TypeSpecifier> <DeclarationSpecifiers?>,
// }

// StorageClassSpecifier = {
//   "auto",
//   "extern",
//   "register",
//   "static",
//   "typedef",
// }

TypeName: ast::TypeSpecifier = <ArithmeticType> => ast::TypeSpecifier::ArithmeticType(<>);




// TypeSpecifier: ast::TypeSpecifier = {
//   CharType,
//   ShortType,
//   IntType,
//   LongType,
//   "void" => ast::TypeSpecifier::Void,  
//   "float" => ast::TypeSpecifier::F32,
//   "double" => ast::TypeSpecifier::F64,
//   "_Bool" => ast::TypeSpecifier::Bool,
//   <StructType> => ast::TypeSpecifier::Struct(<>),
//   <UnionType> => ast::TypeSpecifier::Union(<>),
//   "enum" <Identifier> => ast::TypeSpecifier::Enum(<>),
// }

// StructType = {
//   "struct" <Identifier>,
//   "struct" <Identifier?> "{" <StructDeclarationList> "}",
// }

// UnionType = {
//   "union" <Identifier>,
//   "union" <Identifier?> "{" <StructDeclarationList> "}",
// }

// StructDeclarationList = {
//   <StructDeclaration>,
//   <StructDeclarationList> <StructDeclaration>,
// }

// StructDeclaration = {
//   <SpecifierQualifierList> <DeclaratorList?> ";",
// }

// SpecifierQualifierList = {
//   <TypeSpecifier> <SpecifierQualifierList?>,
//   <TypeQualifier> <SpecifierQualifierList?>,
// }

// TypeQualifier = {
//   "const"
// }

// DeclaratorList = {
//   <Declarator>,
//   <DeclaratorList> "," <Declarator>
// }




// EXPRESSIONS ------------------------------

ConstantExpression = ConditionalExpression;

pub Expression: Box<ast::Expression> = {
  AssignmentExpression,
  <Expression> "," <AssignmentExpression> => Box::new(ast::Expression::ExpressionList(<>))
};

AssignmentExpression: Box<ast::Expression> = {
  ConditionalExpression,
  <UnaryExpression> "=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, None)),
  <UnaryExpression> "*=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, Some(ast::BinaryOperator::Mult))),
  <UnaryExpression> "/=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, Some(ast::BinaryOperator::Div))),
  <UnaryExpression> "%=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, Some(ast::BinaryOperator::Mod))),
  <UnaryExpression> "+=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, Some(ast::BinaryOperator::Add))),
  <UnaryExpression> "-=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, Some(ast::BinaryOperator::Sub))),
  <UnaryExpression> "<<=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, Some(ast::BinaryOperator::LeftShift))),
  <UnaryExpression> ">>=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, Some(ast::BinaryOperator::RightShift))),
  <UnaryExpression> "&=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, Some(ast::BinaryOperator::BitwiseAnd))),
  <UnaryExpression> "^=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, Some(ast::BinaryOperator::BitwiseXor))),
  <UnaryExpression> "|=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, Some(ast::BinaryOperator::BitwiseOr))),
}

ConditionalExpression: Box<ast::Expression> = {
  LogicalOrExpression,
  <LogicalOrExpression> "?" <Expression> ":" <ConditionalExpression>
    => Box::new(ast::Expression::Ternary(<>)),
};

LogicalOrExpression: Box<ast::Expression> = {
  LogicalAndExpression,
  <LogicalOrExpression> "||" <LogicalAndExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::LogicalOr, <>)),
};

LogicalAndExpression: Box<ast::Expression> = {
  InclusiveOrExpression,
  <LogicalAndExpression> "&&" <InclusiveOrExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::LogicalAnd, <>)),
};

InclusiveOrExpression: Box<ast::Expression> = {
  ExclusiveOrExpression,
  <InclusiveOrExpression> "|" <ExclusiveOrExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::BitwiseOr, <>)),
};

ExclusiveOrExpression: Box<ast::Expression> = {
  AndExpression,
  <ExclusiveOrExpression> "^" <AndExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::BitwiseXor, <>)),
};

AndExpression: Box<ast::Expression> = {
  EqualityExpression,
  <AndExpression> "&" <EqualityExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::BitwiseAnd, <>)),
};

EqualityExpression: Box<ast::Expression> = {
  RelationalExpression,
  <EqualityExpression> "==" <RelationalExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::Equal, <>)),
  <EqualityExpression> "!=" <RelationalExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::NotEqual, <>)),
};

RelationalExpression: Box<ast::Expression> = {
  ShiftExpression,
  <RelationalExpression> "<" <ShiftExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::LessThan, <>)),
  <RelationalExpression> ">" <ShiftExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::GreaterThan, <>)),
  <RelationalExpression> "<=" <ShiftExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::LessThanEq, <>)),
  <RelationalExpression> ">=" <ShiftExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::GreaterThanEq, <>)),
};

ShiftExpression: Box<ast::Expression> = {
  AdditiveExpression,
  <ShiftExpression> "<<" <AdditiveExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::LeftShift, <>)),
  <ShiftExpression> ">>" <AdditiveExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::RightShift, <>)),
};

AdditiveExpression: Box<ast::Expression> = {
  MultiplicativeExpression,
  <AdditiveExpression> "+" <MultiplicativeExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::Add, <>)),
  <AdditiveExpression> "-" <MultiplicativeExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::Sub, <>)),
};

MultiplicativeExpression: Box<ast::Expression> = {
  CastExpression,
  <MultiplicativeExpression> "*" <CastExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::Mult, <>)),
  <MultiplicativeExpression> "/" <CastExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::Div, <>)),
  <MultiplicativeExpression> "%" <CastExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::Mod, <>)),
};

CastExpression: Box<ast::Expression> = {
  UnaryExpression,
  "(" <TypeName> ")" <CastExpression> => Box::new(ast::Expression::Cast(<>)),
};

UnaryExpression = {
  PostfixExpression,
  "++" <UnaryExpression> => Box::new(ast::Expression::PrefixIncrement(<>)),
  "--" <UnaryExpression> => Box::new(ast::Expression::PrefixDecrement(<>)),
  <UnaryOperator> <CastExpression> => Box::new(ast::Expression::UnaryOp(<>)),
  "sizeof" <UnaryExpression> => Box::new(ast::Expression::SizeOfExpr(<>)),
  "sizeof" "(" <TypeName> ")" => Box::new(ast::Expression::SizeOfType(<>)),
};

UnaryOperator: ast::UnaryOperator = {
  "&" => ast::UnaryOperator::AddressOf,
  "*" => ast::UnaryOperator::Dereference,
  "+" => ast::UnaryOperator::Plus,
  "-" => ast::UnaryOperator::Minus,
  "~" => ast::UnaryOperator::BitwiseNot,
  "!" => ast::UnaryOperator::LogicalNot,
};

PostfixExpression: Box<ast::Expression> = {
  <PrimaryExpression>,
  <PostfixExpression> "[" <Expression> "]" => Box::new(ast::Expression::Index(<>)),
  <PostfixExpression> "(" <ArgumentExpressionList?> ")" => Box::new(ast::Expression::FunctionCall(<>)),
  <PostfixExpression> "." <Identifier> => Box::new(ast::Expression::DirectMemberSelection(<>)),
  <PostfixExpression> "->" <Identifier> => Box::new(ast::Expression::IndirectMemberSelection(<>)),
  <PostfixExpression> "++" => Box::new(ast::Expression::PostfixIncrement(<>)),
  <PostfixExpression> "--" => Box::new(ast::Expression::PostfixDecrement(<>)),
};

ArgumentExpressionList: Vec<Box<ast::Expression>> = {
  <AssignmentExpression> => vec![<>],
  <v:ArgumentExpressionList> "," <e:AssignmentExpression> => {
    let mut newv = v.to_vec();
    newv.push(e);
    newv
  },
};

PrimaryExpression: Box<ast::Expression> = {
  <Identifier> => Box::new(ast::Expression::Identifier(<>)),
  <Constant> => Box::new(ast::Expression::Constant(<>)),
  <StringLiteral> => Box::new(ast::Expression::StringLiteral(<>)),
  "(" <Expression> ")",
};