use crate::parser::ast;
use crate::parser::interpret_string::interpret_string;

grammar;

// LALRPOP MACROS

CommaSepList<T>: Vec<T> = {
  <mut v:(<T> ",")*> <e:T> => {
    v.push(e);
    v
  }
};

CommaSepListAllowTrailing<T>: Vec<T> = {
  <mut v:(<T> ",")*> <e:T?> => match e {
    None => v,
    Some(e) => {
      v.push(e);
      v
    }
  }
};



// CONSTANTS -------------------------

pub Identifier: ast::Identifier = r"[a-zA-Z_][a-zA-Z0-9_]*"
  => ast::Identifier(<>.to_owned());

pub Constant: ast::Constant = {
  IntegerConstant => ast::Constant::Int(<>),
  DecimalFloatingConstant => ast::Constant::Float(<>),
  CharConstant => ast::Constant::Char(<>),
};

IntegerConstant: u128 = {
  DecimalConstant,
  BinaryConstant,
  OctalConstant,
  HexadecimalConstant,
};

DecimalConstant: u128 = r"[1-9][0-9]*"
  => u128::from_str_radix(&<>, 10).unwrap();

BinaryConstant: u128 = r"0(b|B)[0-1]+"
  => u128::from_str_radix(&<>[2..], 2).unwrap();

OctalConstant: u128 = r"0[0-7]*"
  => u128::from_str_radix(&<>, 8).unwrap();

HexadecimalConstant: u128 = r"0(x|X)[0-9A-Fa-f]+"
  => u128::from_str_radix(&<>[2..], 16).unwrap();

DecimalFloatingConstant: f64 = r"((([0-9]*\.[0-9]+)|([0-9]+\.))((e|E)(\+|-)?[0-9]+)?)|([0-9]+(e|E)(\+|-)?[0-9]+)" => <>.parse::<f64>().unwrap();

// remove leading and trailing double quote using slice
pub StringLiteral: String = r#"".*""# => interpret_string(&<>[1..(<>.len()-1)]).unwrap();

CharConstant: char = {
  "'" <SpecialChar> "'",
  r"'[^'\\]'" => <>.chars().nth(1).unwrap(),
};

SpecialChar: char = {
  r"\\'" => '\'',
  r#"\\""# => '"',
  r"\\?" => '?',
  r"\\\\" => '\\',
  r"\\n" => '\n',
  r"\\r" => '\r',
  r"\\t" => '\t',
  r"\\x[0-9A-Fa-f]+" => char::from_u32(u32::from_str_radix(&<>[2..], 16).unwrap()).unwrap(),
  r"\\[0-7]+" => char::from_u32(u32::from_str_radix(&<>[1..], 8).unwrap()).unwrap(),
};


// STATEMENTS -------------------------------

pub Program: ast::StatementList = <Statement+> => ast::StatementList(<>);

pub Statement: Box<ast::Statement> = {
  OpenStatement,
  ClosedStatement,
};

OpenStatement: Box<ast::Statement> = {
  "if" "(" <Expression> ")" <Statement> => Box::new(ast::Statement::If(<>)),
  "if" "(" <Expression> ")" <ClosedStatement> "else" <OpenStatement> => Box::new(ast::Statement::IfElse(<>)),
  "while" "(" <Expression> ")" <OpenStatement> => Box::new(ast::Statement::While(<>)),
  "for" "(" <ExpressionOrDeclaration?> ";" <Expression?> ";" <Expression?> ")" <OpenStatement> => Box::new(ast::Statement::For(<>)),
};

ClosedStatement: Box<ast::Statement> = {
  "if" "(" <Expression> ")" <ClosedStatement> "else" <ClosedStatement> => Box::new(ast::Statement::IfElse(<>)),
  "goto" <Identifier> ";" => Box::new(ast::Statement::Goto(<>)),
  "continue" ";" => Box::new(ast::Statement::Continue),
  "break" ";" => Box::new(ast::Statement::Break),
  "return" <Expression?> ";" => Box::new(ast::Statement::Return(<>)),
  "while" "(" <Expression> ")" <ClosedStatement> => Box::new(ast::Statement::While(<>)),
  "do" <Statement> "while" "(" <Expression> ")" ";" => Box::new(ast::Statement::DoWhile(<>)),
  "for" "(" <ExpressionOrDeclaration?> ";" <Expression?> ";" <Expression?> ")" <ClosedStatement> => Box::new(ast::Statement::For(<>)),
  "switch" "(" <Expression> ")" <ClosedStatement> => Box::new(ast::Statement::Switch(<>)),
  Block,
  <Expression> ";" => Box::new(ast::Statement::Expr(<>)),
  <Declaration>,
};

Block: Box<ast::Statement> = {
  "{" <Statement+> "}" => Box::new(ast::Statement::Block(<>)),
  "{" "}" => Box::new(ast::Statement::Block(vec![])),
};

LabelledStatement: Box<ast::Statement> = {
  "case" ConditionalExpression ":" Statement => Box::new(ast::Statement::Labelled(ast::LabelledStatement::Case)),
  "default" ":" Statement => Box::new(ast::Statement::Labelled(ast::LabelledStatement::Default)),
  <Identifier> ":" Statement => Box::new(ast::Statement::Labelled(ast::LabelledStatement::Named(<>))),
};

// for for statements, where the first expression can be either an expression
// or a declaration
#[inline]
ExpressionOrDeclaration: ast::ExpressionOrDeclaration = {
  <Expression> => ast::ExpressionOrDeclaration::Expression(<>),
  <SpecifierQualifier+> <DeclaratorInitialiserList> => ast::ExpressionOrDeclaration::Declaration(Box::new(ast::Statement::Declaration(<>))),
};

// DECLARATIONS -----------------------------

pub Declaration: Box<ast::Statement> = {
  <SpecifierQualifier+> <DeclaratorInitialiserList> ";" => Box::new(ast::Statement::Declaration(<>)),
  <SpecifierQualifier+> <Declarator> <Block> => Box::new(ast::Statement::FunctionDeclaration(<>)),
  // for structs, unions, enums
  <SpecifierQualifier+> ";" => Box::new(ast::Statement::EmptyDeclaration(<>)),
};

pub SpecifierQualifier: ast::SpecifierQualifier = {
  <TypeSpecifier> => ast::SpecifierQualifier::TypeSpecifier(<>),
  <StorageClassSpecifier> => ast::SpecifierQualifier::StorageClassSpecifier(<>),
  <TypeQualifier> => ast::SpecifierQualifier::TypeQualifier(<>),
};

pub TypeSpecifier: ast::TypeSpecifier = {
  <ArithmeticTypeSpecifier> => ast::TypeSpecifier::ArithmeticType(<>),
  "void" => ast::TypeSpecifier::Void,
  <StructDeclaration> => ast::TypeSpecifier::Struct(<>),
  <UnionDeclaration> => ast::TypeSpecifier::Union(<>),
  <EnumDeclaration> => ast::TypeSpecifier::Enum(<>),
};

StorageClassSpecifier: ast::StorageClassSpecifier = {
  "auto" => ast::StorageClassSpecifier::Auto,
  "extern" => ast::StorageClassSpecifier::Extern,
  "register" => ast::StorageClassSpecifier::Register,
  "static" => ast::StorageClassSpecifier::Static,
  "typedef" => ast::StorageClassSpecifier::Typedef,
};

TypeQualifier: ast::TypeQualifier = {
  "const" => ast::TypeQualifier::Const,
};

ArithmeticTypeSpecifier: ast::ArithmeticTypeSpecifier = {
  "char" => ast::ArithmeticTypeSpecifier::Char,
  "short" => ast::ArithmeticTypeSpecifier::Short,
  "int" => ast::ArithmeticTypeSpecifier::Int,
  "long" => ast::ArithmeticTypeSpecifier::Long,
  "signed" => ast::ArithmeticTypeSpecifier::Signed,
  "unsigned" => ast::ArithmeticTypeSpecifier::Unsigned,
  "float" => ast::ArithmeticTypeSpecifier::Float,
  "double" => ast::ArithmeticTypeSpecifier::Double,
};

StructDeclaration: ast::StructType = {
  "struct" <Identifier> => ast::StructType::Declaration(<>),
  "struct" <Identifier?> "{" <StructMemberDeclaration+> "}" => ast::StructType::Definition(<>),
};

StructMemberDeclaration: ast::StructMemberDeclaration = {
  <SpecifierQualifier+> <DeclaratorList> ";" => ast::StructMemberDeclaration(<>),
};

UnionDeclaration: ast::UnionType = {
  "union" <Identifier> => ast::UnionType::Declaration(<>),
  "union" <Identifier?> "{" <StructMemberDeclaration+> "}" => ast::UnionType::Definition(<>),
};

EnumDeclaration: ast::EnumType = {
  "enum" <Identifier> => ast::EnumType::Declaration(<>),
  "enum" <Identifier?> "{" <EnumeratorList> "}" => ast::EnumType::Definition(<>),
};

EnumeratorList = CommaSepListAllowTrailing<Enumerator>;

Enumerator: ast::Enumerator = {
  <Identifier> => ast::Enumerator::Simple(<>),
  <Identifier> "=" <ConstantExpression> => ast::Enumerator::WithValue(<>),
};

DeclaratorList = CommaSepList<Declarator>;

Declarator: Box<ast::Declarator> = {
  <PtrDeclarator>,
  <NoPtrDeclarator>,
};

PtrDeclarator: Box<ast::Declarator> = {
  "*" <Declarator?> => match <> {
    None => Box::new(ast::Declarator::AbstractPointerDeclarator),
    Some(d) => Box::new(ast::Declarator::PointerDeclarator(d)),
  }
};

NoPtrDeclarator: Box<ast::Declarator> = {
  <Identifier> => Box::new(ast::Declarator::Identifier(<>)),
  "(" <Declarator> ")",
  // Array declarator
  <NoPtrDeclarator> "[" <AssignmentExpression?> "]" => Box::new(ast::Declarator::ArrayDeclarator(<>)),
  // Function declarator
  <NoPtrDeclarator> "(" <ParameterTypeList?> ")" => Box::new(ast::Declarator::FunctionDeclarator(<>)),
};

// AbstractDeclarator: Box<ast::Declarator> = {
//   "*" => Box::new(ast::Declarator::AbstractPointerDeclarator),
//   <AbstractNoPtrDeclarator>,
// };

// AbstractNoPtrDeclarator: Box<ast::Declarator> = {
//   "(" <AbstractDeclarator> ")",
//   <AbstractNoPtrDeclarator> "[" <AssignmentExpression?> "]" => Box::new(ast::Declarator::ArrayDeclarator(<>)),
//   <AbstractNoPtrDeclarator> "(" <ParameterTypeList?> ")" => Box::new(ast::Declarator::FunctionDeclarator(<>)),
// };

ParameterTypeList: ast::ParameterTypeList = {
  <ParameterList> => ast::ParameterTypeList::Normal(<>),
  // variadic functions
  //<ParameterList> "," "..." => ast::ParameterTypeList::Variadic(<>),
};

ParameterList = CommaSepList<ParameterDeclaration>;

ParameterDeclaration: ast::ParameterDeclaration = {
  <SpecifierQualifier+> <Declarator> => ast::ParameterDeclaration::Named(<>),
  // <SpecifierQualifier+> <AbstractDeclarator?> => ast::ParameterDeclaration::Abstract(<>),
};

DeclaratorInitialiserList = CommaSepList<DeclaratorInitialiser>;

DeclaratorInitialiser: ast::DeclaratorInitialiser = {
  <Declarator> => ast::DeclaratorInitialiser::NoInit(<>),
  <Declarator> "=" <ConstantExpression> => ast::DeclaratorInitialiser::Init(<>),
  <Declarator> "=" "{" <CommaSepListAllowTrailing<ConstantExpression>> "}" => ast::DeclaratorInitialiser::StructOrUnion(<>),
};


// TypeName: ast::TypeName = {
//   // <SpecifierQualifier+> <AbstractDeclarator?>,
//   <SpecifierQualifier+> <Declarator?> => ast::TypeName(<>),
// };





// EXPRESSIONS ------------------------------

ConstantExpression = ConditionalExpression;

pub Expression: Box<ast::Expression> = {
  AssignmentExpression,
  <Expression> "," <AssignmentExpression> => Box::new(ast::Expression::ExpressionList(<>))
};

AssignmentExpression: Box<ast::Expression> = {
  ConditionalExpression,
  <ConditionalExpression> "=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, None)),
  <ConditionalExpression> "*=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, Some(ast::BinaryOperator::Mult))),
  <ConditionalExpression> "/=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, Some(ast::BinaryOperator::Div))),
  <ConditionalExpression> "%=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, Some(ast::BinaryOperator::Mod))),
  <ConditionalExpression> "+=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, Some(ast::BinaryOperator::Add))),
  <ConditionalExpression> "-=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, Some(ast::BinaryOperator::Sub))),
  <ConditionalExpression> "<<=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, Some(ast::BinaryOperator::LeftShift))),
  <ConditionalExpression> ">>=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, Some(ast::BinaryOperator::RightShift))),
  <ConditionalExpression> "&=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, Some(ast::BinaryOperator::BitwiseAnd))),
  <ConditionalExpression> "^=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, Some(ast::BinaryOperator::BitwiseXor))),
  <ConditionalExpression> "|=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, Some(ast::BinaryOperator::BitwiseOr))),
}

ConditionalExpression: Box<ast::Expression> = {
  LogicalOrExpression,
  <LogicalOrExpression> "?" <Expression> ":" <ConditionalExpression>
    => Box::new(ast::Expression::Ternary(<>)),
};

LogicalOrExpression: Box<ast::Expression> = {
  LogicalAndExpression,
  <LogicalOrExpression> "||" <LogicalAndExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::LogicalOr, <>)),
};

LogicalAndExpression: Box<ast::Expression> = {
  InclusiveOrExpression,
  <LogicalAndExpression> "&&" <InclusiveOrExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::LogicalAnd, <>)),
};

InclusiveOrExpression: Box<ast::Expression> = {
  ExclusiveOrExpression,
  <InclusiveOrExpression> "|" <ExclusiveOrExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::BitwiseOr, <>)),
};

ExclusiveOrExpression: Box<ast::Expression> = {
  AndExpression,
  <ExclusiveOrExpression> "^" <AndExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::BitwiseXor, <>)),
};

AndExpression: Box<ast::Expression> = {
  EqualityExpression,
  <AndExpression> "&" <EqualityExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::BitwiseAnd, <>)),
};

EqualityExpression: Box<ast::Expression> = {
  RelationalExpression,
  <EqualityExpression> "==" <RelationalExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::Equal, <>)),
  <EqualityExpression> "!=" <RelationalExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::NotEqual, <>)),
};

RelationalExpression: Box<ast::Expression> = {
  ShiftExpression,
  <RelationalExpression> "<" <ShiftExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::LessThan, <>)),
  <RelationalExpression> ">" <ShiftExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::GreaterThan, <>)),
  <RelationalExpression> "<=" <ShiftExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::LessThanEq, <>)),
  <RelationalExpression> ">=" <ShiftExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::GreaterThanEq, <>)),
};

ShiftExpression: Box<ast::Expression> = {
  AdditiveExpression,
  <ShiftExpression> "<<" <AdditiveExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::LeftShift, <>)),
  <ShiftExpression> ">>" <AdditiveExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::RightShift, <>)),
};

AdditiveExpression: Box<ast::Expression> = {
  MultiplicativeExpression,
  <AdditiveExpression> "+" <MultiplicativeExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::Add, <>)),
  <AdditiveExpression> "-" <MultiplicativeExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::Sub, <>)),
};

MultiplicativeExpression: Box<ast::Expression> = {
  CastExpression,
  <MultiplicativeExpression> "*" <CastExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::Mult, <>)),
  <MultiplicativeExpression> "/" <CastExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::Div, <>)),
  <MultiplicativeExpression> "%" <CastExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::Mod, <>)),
};

CastExpression: Box<ast::Expression> = {
  UnaryExpression,
  // "(" <s:SpecifierQualifier+> <d:Declarator?> ")" <e:CastExpression> => Box::new(ast::Expression::Cast(ast::TypeName(s, d), e)),
};

UnaryExpression = {
  PostfixExpression,
  "++" <UnaryExpression> => Box::new(ast::Expression::PrefixIncrement(<>)),
  "--" <UnaryExpression> => Box::new(ast::Expression::PrefixDecrement(<>)),
  <UnaryOperator> <CastExpression> => Box::new(ast::Expression::UnaryOp(<>)),
  "sizeof" <UnaryExpression> => Box::new(ast::Expression::SizeOfExpr(<>)),
  // "sizeof" "(" <SpecifierQualifier+> <Declarator?> ")" => Box::new(ast::Expression::SizeOfType(ast::TypeName(<>))),
};

UnaryOperator: ast::UnaryOperator = {
  "&" => ast::UnaryOperator::AddressOf,
  "*" => ast::UnaryOperator::Dereference,
  "+" => ast::UnaryOperator::Plus,
  "-" => ast::UnaryOperator::Minus,
  "~" => ast::UnaryOperator::BitwiseNot,
  "!" => ast::UnaryOperator::LogicalNot,
};

PostfixExpression: Box<ast::Expression> = {
  <PrimaryExpression>,
  <PostfixExpression> "[" <Expression> "]" => Box::new(ast::Expression::Index(<>)),
  <PostfixExpression> "(" <ArgumentExpressionList?> ")" => Box::new(ast::Expression::FunctionCall(<>)),
  <PostfixExpression> "." <Identifier> => Box::new(ast::Expression::DirectMemberSelection(<>)),
  <PostfixExpression> "->" <Identifier> => Box::new(ast::Expression::IndirectMemberSelection(<>)),
  <PostfixExpression> "++" => Box::new(ast::Expression::PostfixIncrement(<>)),
  <PostfixExpression> "--" => Box::new(ast::Expression::PostfixDecrement(<>)),
};

ArgumentExpressionList = CommaSepList<AssignmentExpression>;

PrimaryExpression: Box<ast::Expression> = {
  <Identifier> => Box::new(ast::Expression::Identifier(<>)),
  <Constant> => Box::new(ast::Expression::Constant(<>)),
  <StringLiteral> => Box::new(ast::Expression::StringLiteral(<>)),
  "(" <Expression> ")",
};