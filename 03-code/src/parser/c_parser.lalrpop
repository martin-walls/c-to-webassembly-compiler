use crate::parser::ast;
use crate::parser::lexer;
use crate::parser::interpret_string::interpret_string;

grammar;

extern {
    type Location = usize;
    type Error = lexer::LexError;

    enum lexer::Token {
        "!" => lexer::Token::Bang,
        "%" => lexer::Token::Percent,
        "^" => lexer::Token::Caret,
        "&" => lexer::Token::Ampersand,
        "*" => lexer::Token::Asterisk,
        "-" => lexer::Token::Minus,
        "+" => lexer::Token::Plus,
        "=" => lexer::Token::Eq,
        "~" => lexer::Token::Tilde,
        "|" => lexer::Token::Bar,
        "." => lexer::Token::Dot,
        "<" => lexer::Token::LessThan,
        ">" => lexer::Token::GreaterThan,
        "/" => lexer::Token::Slash,
        "?" => lexer::Token::Question,

        "+=" => lexer::Token::PlusEq,
        "-=" => lexer::Token::MinusEq,
        "*=" => lexer::Token::AsteriskEq,
        "/=" => lexer::Token::SlashEq,
        "%=" => lexer::Token::PercentEq,
        "<<=" => lexer::Token::LeftShiftEq,
        ">>=" => lexer::Token::RightShiftEq,
        "&=" => lexer::Token::AmpersandEq,
        "^=" => lexer::Token::CaretEq,
        "|=" => lexer::Token::BarEq,

        "->" => lexer::Token::Arrow,
        "++" => lexer::Token::DoublePlus,
        "--" => lexer::Token::DoubleMinus,
        "<<" => lexer::Token::LeftShift,
        ">>" => lexer::Token::RightShift,
        "<=" => lexer::Token::LessThanEq,
        ">=" => lexer::Token::GreaterThanEq,
        "==" => lexer::Token::DoubleEq,
        "!=" => lexer::Token::BangEq,
        "&&" => lexer::Token::DoubleAmpersand,
        "||" => lexer::Token::DoubleBar,

        "(" => lexer::Token::LeftParen,
        ")" => lexer::Token::RightParen,
        "[" => lexer::Token::LeftSquare,
        "]" => lexer::Token::RightSquare,
        "{" => lexer::Token::LeftCurly,
        "}" => lexer::Token::RightCurly,
        "," => lexer::Token::Comma,
        ";" => lexer::Token::Semicolon,
        ":" => lexer::Token::Colon,

        "'" => lexer::Token::SingleQuote,
        "\"" => lexer::Token::DoubleQuote,

        "..." => lexer::Token::Ellipsis,

        "DecimalConstant" => lexer::Token::DecimalConstant(<String>),
        "BinaryConstant" => lexer::Token::BinaryConstant(<String>),
        "OctalConstant" => lexer::Token::OctalConstant(<String>),
        "HexConstant" => lexer::Token::HexConstant(<String>),
        "FloatingConstant" => lexer::Token::FloatingConstant(<String>),
        "StringLiteral" => lexer::Token::StringLiteral(<String>),
        "CharConstant" => lexer::Token::CharConstant(<String>),

        "Identifier" => lexer::Token::Identifier(<String>),
        "TypedefName" => lexer::Token::TypedefName(<String>),

        "auto" => lexer::Token::Auto,
        "break" => lexer::Token::Break,
        "case" => lexer::Token::Case,
        "char" => lexer::Token::Char,
        "const" => lexer::Token::Const,
        "continue" => lexer::Token::Continue,
        "default" => lexer::Token::Default,
        "do" => lexer::Token::Do,
        "double" => lexer::Token::Double,
        "else" => lexer::Token::Else,
        "enum" => lexer::Token::Enum,
        "extern" => lexer::Token::Extern,
        "float" => lexer::Token::Float,
        "for" => lexer::Token::For,
        "goto" => lexer::Token::Goto,
        "if" => lexer::Token::If,
        "inline" => lexer::Token::Inline,
        "int" => lexer::Token::Int,
        "long" => lexer::Token::Long,
        "register" => lexer::Token::Register,
        "return" => lexer::Token::Return,
        "short" => lexer::Token::Short,
        "signed" => lexer::Token::Signed,
        "sizeof" => lexer::Token::Sizeof,
        "static" => lexer::Token::Static,
        "struct" => lexer::Token::Struct,
        "switch" => lexer::Token::Switch,
        "typedef" => lexer::Token::Typedef,
        "union" => lexer::Token::Union,
        "unsigned" => lexer::Token::Unsigned,
        "void" => lexer::Token::Void,
        "volatile" => lexer::Token::Volatile,
        "while" => lexer::Token::While,
    }
}

// LALRPOP MACROS

CommaSepList<T>: Vec<T> = {
  <mut v:(<T> ",")*> <e:T> => {
    v.push(e);
    v
  }
};

CommaSepListAllowTrailing<T>: Vec<T> = {
  <mut v:(<T> ",")*> <e:T?> => match e {
    None => v,
    Some(e) => {
      v.push(e);
      v
    }
  }
};

CommaSepListWithTrailing<T>: Vec<T> = {
  <(<T> ",")+>
};

// CONSTANTS -------------------------

pub Identifier: ast::Identifier = "Identifier" => ast::Identifier(<>.to_owned());

pub Constant: ast::Constant = {
  IntegerConstant => ast::Constant::Int(<>),
  DecimalFloatingConstant => ast::Constant::Float(<>),
  CharConstant => ast::Constant::Char(<>),
};

IntegerConstant: u128 = {
  DecimalConstant,
  BinaryConstant,
  OctalConstant,
  HexConstant,
};

DecimalConstant: u128 = "DecimalConstant" => u128::from_str_radix(&<>, 10).unwrap();

BinaryConstant: u128 = "BinaryConstant" => u128::from_str_radix(&<>[2..], 2).unwrap();

OctalConstant: u128 = "OctalConstant" => u128::from_str_radix(&<>, 8).unwrap();

HexConstant: u128 = "HexConstant" => u128::from_str_radix(&<>[2..], 16).unwrap();

DecimalFloatingConstant: f64 = "FloatingConstant" => <>.parse::<f64>().unwrap();

// remove leading and trailing double quote using slice
pub StringLiteral: String = "StringLiteral" => interpret_string(&<>).unwrap();

CharConstant: char = "CharConstant" => interpret_string(&<>).unwrap().chars().nth(0).unwrap();

// STATEMENTS -------------------------------

pub Program: ast::StatementList = <Statement+> => ast::StatementList(<>);

pub Statement: Box<ast::Statement> = {
  OpenStatement,
  ClosedStatement,
};

OpenStatement: Box<ast::Statement> = {
  "if" "(" <Expression> ")" <Statement> => Box::new(ast::Statement::If(<>)),
  "if" "(" <Expression> ")" <ClosedStatement> "else" <OpenStatement> => Box::new(ast::Statement::IfElse(<>)),
  "while" "(" <Expression> ")" <OpenStatement> => Box::new(ast::Statement::While(<>)),
  "for" "(" <ExpressionOrDeclaration?> ";" <Expression?> ";" <Expression?> ")" <OpenStatement> => Box::new(ast::Statement::For(<>)),
  "switch" "(" <Expression> ")" <OpenStatement> => Box::new(ast::Statement::Switch(<>)),
  "case" <ConditionalExpression> ":" <OpenStatement> => Box::new(ast::Statement::Labelled(ast::LabelledStatement::Case(<>))),
  "default" ":" <OpenStatement> => Box::new(ast::Statement::Labelled(ast::LabelledStatement::Default(<>))),
  <Identifier> ":" <OpenStatement> => Box::new(ast::Statement::Labelled(ast::LabelledStatement::Named(<>))),
};

ClosedStatement: Box<ast::Statement> = {
  "if" "(" <Expression> ")" <ClosedStatement> "else" <ClosedStatement> => Box::new(ast::Statement::IfElse(<>)),
  "goto" <Identifier> ";" => Box::new(ast::Statement::Goto(<>)),
  "continue" ";" => Box::new(ast::Statement::Continue),
  "break" ";" => Box::new(ast::Statement::Break),
  "return" <Expression?> ";" => Box::new(ast::Statement::Return(<>)),
  "while" "(" <Expression> ")" <ClosedStatement> => Box::new(ast::Statement::While(<>)),
  "do" <Statement> "while" "(" <Expression> ")" ";" => Box::new(ast::Statement::DoWhile(<>)),
  "for" "(" <ExpressionOrDeclaration?> ";" <Expression?> ";" <Expression?> ")" <ClosedStatement> => Box::new(ast::Statement::For(<>)),
  "switch" "(" <Expression> ")" <ClosedStatement> => Box::new(ast::Statement::Switch(<>)),
  Block,
  <Expression> ";" => Box::new(ast::Statement::Expr(<>)),
  <Declaration>,
  "case" <ConditionalExpression> ":" <ClosedStatement> => Box::new(ast::Statement::Labelled(ast::LabelledStatement::Case(<>))),
  "default" ":" <ClosedStatement> => Box::new(ast::Statement::Labelled(ast::LabelledStatement::Default(<>))),
  <Identifier> ":" <ClosedStatement> => Box::new(ast::Statement::Labelled(ast::LabelledStatement::Named(<>))),
  ";" => Box::new(ast::Statement::Empty),
};

Block: Box<ast::Statement> = {
  "{" <Statement*> "}" => Box::new(ast::Statement::Block(<>)),
};

// for for statements, where the first expression can be either an expression
// or a declaration
#[inline]
ExpressionOrDeclaration: ast::ExpressionOrDeclaration = {
  <Expression> => ast::ExpressionOrDeclaration::Expression(<>),
  <SpecifierQualifier+> <DeclaratorInitialiserList> => ast::ExpressionOrDeclaration::Declaration(Box::new(ast::Statement::Declaration(<>))),
};

// DECLARATIONS -----------------------------

pub Declaration: Box<ast::Statement> = {
  <SpecifierQualifier+> <DeclaratorInitialiserList> ";" => Box::new(ast::Statement::Declaration(<>)),
  <SpecifierQualifier+> <Declarator> <Block> => Box::new(ast::Statement::FunctionDeclaration(<>)),
  // for structs, unions, enums
  <SpecifierQualifier+> ";" => Box::new(ast::Statement::EmptyDeclaration(<>)),
};

pub SpecifierQualifier: ast::SpecifierQualifier = {
  <TypeSpecifier> => ast::SpecifierQualifier::TypeSpecifier(<>),
  <StorageClassSpecifier> => ast::SpecifierQualifier::StorageClassSpecifier(<>),
  <TypeQualifier> => ast::SpecifierQualifier::TypeQualifier(<>),
  <FunctionSpecifier> => ast::SpecifierQualifier::FunctionSpecifier(<>),
};

pub TypeSpecifier: ast::TypeSpecifier = {
  <ArithmeticTypeSpecifier> => ast::TypeSpecifier::ArithmeticType(<>),
  "void" => ast::TypeSpecifier::Void,
  <StructDeclaration> => ast::TypeSpecifier::Struct(<>),
  <UnionDeclaration> => ast::TypeSpecifier::Union(<>),
  <EnumDeclaration> => ast::TypeSpecifier::Enum(<>),
  <TypeName> => ast::TypeSpecifier::CustomType(<>),
};

TypeName: ast::Identifier = "TypedefName" => ast::Identifier(<>.to_owned());

StorageClassSpecifier: ast::StorageClassSpecifier = {
  "auto" => ast::StorageClassSpecifier::Auto,
  "extern" => ast::StorageClassSpecifier::Extern,
  "register" => ast::StorageClassSpecifier::Register,
  "static" => ast::StorageClassSpecifier::Static,
  "typedef" => ast::StorageClassSpecifier::Typedef,
};

TypeQualifier: ast::TypeQualifier = {
  "const" => ast::TypeQualifier::Const,
};

FunctionSpecifier: ast::FunctionSpecifier = {
    "inline" => ast::FunctionSpecifier::Inline,
};

ArithmeticTypeSpecifier: ast::ArithmeticTypeSpecifier = {
  "char" => ast::ArithmeticTypeSpecifier::Char,
  "short" => ast::ArithmeticTypeSpecifier::Short,
  "int" => ast::ArithmeticTypeSpecifier::Int,
  "long" => ast::ArithmeticTypeSpecifier::Long,
  "signed" => ast::ArithmeticTypeSpecifier::Signed,
  "unsigned" => ast::ArithmeticTypeSpecifier::Unsigned,
  "float" => ast::ArithmeticTypeSpecifier::Float,
  "double" => ast::ArithmeticTypeSpecifier::Double,
};

StructDeclaration: ast::StructType = {
  "struct" <Identifier> => ast::StructType::Declaration(<>),
  "struct" <Identifier?> "{" <StructMemberDeclaration+> "}" => ast::StructType::Definition(<>),
};

StructMemberDeclaration: ast::StructMemberDeclaration = {
  <SpecifierQualifier+> <DeclaratorList> ";" => ast::StructMemberDeclaration(<>),
};

UnionDeclaration: ast::UnionType = {
  "union" <Identifier> => ast::UnionType::Declaration(<>),
  "union" <Identifier?> "{" <StructMemberDeclaration+> "}" => ast::UnionType::Definition(<>),
};

EnumDeclaration: ast::EnumType = {
  "enum" <Identifier> => ast::EnumType::Declaration(<>),
  "enum" <Identifier?> "{" <EnumeratorList> "}" => ast::EnumType::Definition(<>),
};

EnumeratorList = CommaSepListAllowTrailing<Enumerator>;

Enumerator: ast::Enumerator = {
  <Identifier> => ast::Enumerator::Simple(<>),
  <Identifier> "=" <ConstantExpression> => ast::Enumerator::WithValue(<>),
};

DeclaratorList = CommaSepList<Declarator>;

Declarator: Box<ast::Declarator> = {
  <PtrDeclarator>,
  <NoPtrDeclarator>,
};

PtrDeclarator: Box<ast::Declarator> = {
  "*" <Declarator?> => match <> {
    None => Box::new(ast::Declarator::AbstractPointerDeclarator),
    Some(d) => Box::new(ast::Declarator::PointerDeclarator(d)),
  }
};

NoPtrDeclarator: Box<ast::Declarator> = {
  <Identifier> => Box::new(ast::Declarator::Identifier(<>)),
  "(" <Declarator> ")",
  // Array declarator
  <NoPtrDeclarator> "[" <AssignmentExpression?> "]" => Box::new(ast::Declarator::ArrayDeclarator(<>)),
  // Function declarator
  <NoPtrDeclarator> "(" <ParameterTypeList?> ")" => Box::new(ast::Declarator::FunctionDeclarator(<>)),
};

// AbstractDeclarator: Box<ast::Declarator> = {
//   "*" => Box::new(ast::Declarator::AbstractPointerDeclarator),
//   <AbstractNoPtrDeclarator>,
// };

// AbstractNoPtrDeclarator: Box<ast::Declarator> = {
//   "(" <AbstractDeclarator> ")",
//   <AbstractNoPtrDeclarator> "[" <AssignmentExpression?> "]" => Box::new(ast::Declarator::ArrayDeclarator(<>)),
//   <AbstractNoPtrDeclarator> "(" <ParameterTypeList?> ")" => Box::new(ast::Declarator::FunctionDeclarator(<>)),
// };

ParameterTypeList: ast::ParameterTypeList = {
  <ParameterList> => ast::ParameterTypeList::Normal(<>),
  // variadic functions
  <CommaSepListWithTrailing<ParameterDeclaration>> "..." => ast::ParameterTypeList::Variadic(<>),
};

ParameterList = CommaSepList<ParameterDeclaration>;

ParameterDeclaration: ast::ParameterDeclaration = {
  <SpecifierQualifier+> <Declarator> => ast::ParameterDeclaration::Named(<>),
  // <SpecifierQualifier+> <AbstractDeclarator?> => ast::ParameterDeclaration::Abstract(<>),
};

DeclaratorInitialiserList = CommaSepList<DeclaratorInitialiser>;

DeclaratorInitialiser: ast::DeclaratorInitialiser = {
  <Declarator> => ast::DeclaratorInitialiser::NoInit(<>),
  <Declarator> "=" <Initialiser> => ast::DeclaratorInitialiser::Init(<>),
//  <Declarator> "=" "{" <CommaSepListAllowTrailing<ConstantExpression>> "}" => ast::DeclaratorInitialiser::StructOrUnion(<>),
};

Initialiser: Box<ast::Initialiser> = {
    <AssignmentExpression> => Box::new(ast::Initialiser::Expr(<>)),
    "{" <CommaSepListAllowTrailing<Initialiser>> "}" => Box::new(ast::Initialiser::List(<>)),
};


// TypeName: ast::TypeName = {
//   // <SpecifierQualifier+> <AbstractDeclarator?>,
//   <SpecifierQualifier+> <Declarator?> => ast::TypeName(<>),
// };





// EXPRESSIONS ------------------------------

ConstantExpression = ConditionalExpression;

pub Expression: Box<ast::Expression> = {
  AssignmentExpression,
  <Expression> "," <AssignmentExpression> => Box::new(ast::Expression::ExpressionList(<>))
};

AssignmentExpression: Box<ast::Expression> = {
  ConditionalExpression,
  <ConditionalExpression> "=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, None)),
  <ConditionalExpression> "*=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, Some(ast::BinaryOperator::Mult))),
  <ConditionalExpression> "/=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, Some(ast::BinaryOperator::Div))),
  <ConditionalExpression> "%=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, Some(ast::BinaryOperator::Mod))),
  <ConditionalExpression> "+=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, Some(ast::BinaryOperator::Add))),
  <ConditionalExpression> "-=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, Some(ast::BinaryOperator::Sub))),
  <ConditionalExpression> "<<=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, Some(ast::BinaryOperator::LeftShift))),
  <ConditionalExpression> ">>=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, Some(ast::BinaryOperator::RightShift))),
  <ConditionalExpression> "&=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, Some(ast::BinaryOperator::BitwiseAnd))),
  <ConditionalExpression> "^=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, Some(ast::BinaryOperator::BitwiseXor))),
  <ConditionalExpression> "|=" <AssignmentExpression>
    => Box::new(ast::Expression::Assignment(<>, Some(ast::BinaryOperator::BitwiseOr))),
}

ConditionalExpression: Box<ast::Expression> = {
  <LogicalOrExpression>,
  <LogicalOrExpression> "?" <Expression> ":" <ConditionalExpression>
    => Box::new(ast::Expression::Ternary(<>)),
};

LogicalOrExpression: Box<ast::Expression> = {
  LogicalAndExpression,
  <LogicalOrExpression> "||" <LogicalAndExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::LogicalOr, <>)),
};

LogicalAndExpression: Box<ast::Expression> = {
  InclusiveOrExpression,
  <LogicalAndExpression> "&&" <InclusiveOrExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::LogicalAnd, <>)),
};

InclusiveOrExpression: Box<ast::Expression> = {
  ExclusiveOrExpression,
  <InclusiveOrExpression> "|" <ExclusiveOrExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::BitwiseOr, <>)),
};

ExclusiveOrExpression: Box<ast::Expression> = {
  AndExpression,
  <ExclusiveOrExpression> "^" <AndExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::BitwiseXor, <>)),
};

AndExpression: Box<ast::Expression> = {
  EqualityExpression,
  <AndExpression> "&" <EqualityExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::BitwiseAnd, <>)),
};

EqualityExpression: Box<ast::Expression> = {
  RelationalExpression,
  <EqualityExpression> "==" <RelationalExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::Equal, <>)),
  <EqualityExpression> "!=" <RelationalExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::NotEqual, <>)),
};

RelationalExpression: Box<ast::Expression> = {
  ShiftExpression,
  <RelationalExpression> "<" <ShiftExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::LessThan, <>)),
  <RelationalExpression> ">" <ShiftExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::GreaterThan, <>)),
  <RelationalExpression> "<=" <ShiftExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::LessThanEq, <>)),
  <RelationalExpression> ">=" <ShiftExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::GreaterThanEq, <>)),
};

ShiftExpression: Box<ast::Expression> = {
  AdditiveExpression,
  <ShiftExpression> "<<" <AdditiveExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::LeftShift, <>)),
  <ShiftExpression> ">>" <AdditiveExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::RightShift, <>)),
};

AdditiveExpression: Box<ast::Expression> = {
  MultiplicativeExpression,
  <AdditiveExpression> "+" <MultiplicativeExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::Add, <>)),
  <AdditiveExpression> "-" <MultiplicativeExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::Sub, <>)),
};

MultiplicativeExpression: Box<ast::Expression> = {
  CastExpression,
  <MultiplicativeExpression> "*" <CastExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::Mult, <>)),
  <MultiplicativeExpression> "/" <CastExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::Div, <>)),
  <MultiplicativeExpression> "%" <CastExpression>
    => Box::new(ast::Expression::BinaryOp(ast::BinaryOperator::Mod, <>)),
};

CastExpression: Box<ast::Expression> = {
  UnaryExpression,
  "(" <s:SpecifierQualifier+> <d:Declarator?> ")" <e:CastExpression> => Box::new(ast::Expression::Cast(ast::TypeName::Unnormalised(s, d), e)),
};

UnaryExpression = {
  PostfixExpression,
  "++" <UnaryExpression> => Box::new(ast::Expression::PrefixIncrement(<>)),
  "--" <UnaryExpression> => Box::new(ast::Expression::PrefixDecrement(<>)),
  <UnaryOperator> <CastExpression> => Box::new(ast::Expression::UnaryOp(<>)),
  "sizeof" <UnaryExpression> => Box::new(ast::Expression::SizeOfExpr(<>)),
   "sizeof" "(" <SpecifierQualifier+> <Declarator?> ")" => Box::new(ast::Expression::SizeOfType(ast::TypeName::Unnormalised(<>))),
};

UnaryOperator: ast::UnaryOperator = {
  "&" => ast::UnaryOperator::AddressOf,
  "*" => ast::UnaryOperator::Dereference,
  "+" => ast::UnaryOperator::Plus,
  "-" => ast::UnaryOperator::Minus,
  "~" => ast::UnaryOperator::BitwiseNot,
  "!" => ast::UnaryOperator::LogicalNot,
};

PostfixExpression: Box<ast::Expression> = {
  <PrimaryExpression>,
  <PostfixExpression> "[" <Expression> "]" => Box::new(ast::Expression::Index(<>)),
  <e:PostfixExpression> "(" <args:ArgumentExpressionList?> ")" => {
    match args {
        Some(args) => Box::new(ast::Expression::FunctionCall(e, args)),
        None => Box::new(ast::Expression::FunctionCall(e, vec![])),
    }
  },
  <PostfixExpression> "." <Identifier> => Box::new(ast::Expression::DirectMemberSelection(<>)),
  <PostfixExpression> "->" <Identifier> => Box::new(ast::Expression::IndirectMemberSelection(<>)),
  <PostfixExpression> "++" => Box::new(ast::Expression::PostfixIncrement(<>)),
  <PostfixExpression> "--" => Box::new(ast::Expression::PostfixDecrement(<>)),
};

ArgumentExpressionList = CommaSepList<AssignmentExpression>;

PrimaryExpression: Box<ast::Expression> = {
  <Identifier> => Box::new(ast::Expression::Identifier(<>)),
  <Constant> => Box::new(ast::Expression::Constant(<>)),
  <StringLiteral> => Box::new(ast::Expression::StringLiteral(<>)),
  "(" <Expression> ")",
};