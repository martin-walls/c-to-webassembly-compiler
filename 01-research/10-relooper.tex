\documentclass[10pt, a4paper]{article}

\usepackage{mrw}

\pagestyle{fancy}
\setlength{\headheight}{22.59pt}
\addtolength{\topmargin}{-10.59pt}
\fancyhead[L]{\textbf{Martin Walls}\\mrw64@cam.ac.uk}
\fancyhead[R]{\textbf{The Relooper Algorithm}\\Part II Project}
\fancyfoot[C]{\thepage\ / \pageref{LastPage}}

\usepackage{biblatex}
\addbibresource{11-relooper-references.bib}

\begin{document}
\section{The Relooper Algorithm}

Relooper is an algorithm that turns unstructured control flow into structured control flow.
Unstructured control flow can contain arbitrary branch instructions to anywhere else in the code, whereas structured control flow is bounded within higher-level structures such as if and while blocks.

The Relooper algorithm is described in the Emscripten paper \cite{emscripten}.

\subsection{Input}

The Relooper algorithm takes a so-called `soup of blocks' as input.
Each block is a section of the instructions that starts at a label and ends with a branch instructions (which may be either a conditional branch followed by an unconditional branch, or just an unconditional branch).

\begin{minipage}{0.3\textwidth}
\begin{lstlisting}[style=code, frame=single, escapechar=|]
label:
...
|\textit{non-branch instructions}|
...
if ... goto x     |\rmfamily\small\textit{(optional)}|
goto y
\end{lstlisting}
\end{minipage}

The list of instructions generated in the intermediate representation is processed into a set of these blocks.
They're called a `soup' of blocks because they're no longer stored as a single continuous list, instead each block is separate and points to the blocks to which it can branch.

To avoid overloading the term `block', we call these input blocks `labels'.


\subsection{Output}

The Relooper algorithm generates a set of structured blocks, which are nested to represent the structured control flow.

There are three types of block:

\begin{itemize}
\item \textbf{Simple} blocks, which contain
\begin{itemize}
\item An \textbf{Internal} label
\item A \textbf{Next block}
\end{itemize}

\item \textbf{Loop} blocks, which contain
\begin{itemize}
\item An \textbf{Inner} block
\item A \textbf{Next} block
\end{itemize}

\item \textbf{Multiple} blocks, which contain
\begin{itemize}
\item Some number of \textbf{Handled} blocks
\item A \textbf{Next} block
\end{itemize}
\end{itemize}

\textbf{Simple blocks} are the basic building block, and just contain one of the input labels (which contains the actual code to execute), and point to the block to which execution should pass next.
When this is translated into target code, a Simple block gets translated directly into the code inside the label, and the Next block is put right after it.

\textbf{Loop blocks} represent any kind of loop in the code.
The Inner block contains any labels that can branch back to the start of the loop (along some execution path, which may be multiple labels long).
The Next block contains all the rest of the labels, from which execution will never be able to get back to the start of the loop.

\textbf{Multiple blocks} represent any kind of conditional execution, e.g.\ `if' or `switch' statements.
The Handled blocks are any blocks to which execution can directly pass when we enter this block.
By use of the label variable, described below, we decide which (if any) of the Handled blocks should get executed when we enter the Multiple block.
Once the selected Handled block has finished executing, we go to the Next block.
It's also possible to not execute any of the Handled blocks, for example to represent the control flow of an `if' statement without an `else', in which case execution will go directly to the Next block.


\subsection{Definitions}

\textbf{Labels} are the input blocks, and \textbf{Blocks} are the output blocks, as described above.

When constructing a block from a set of labels, \textbf{Entries} are the subset of those labels that can be immediately reached when the block is executed. (I.e.\ those that are possible branch targets of the previous block.)

Each label has a set of \textbf{possible branch targets}. These are the labels to which this label directly branches.

Each label has a set of other labels which it can \textbf{Reach}. This is the transitive closure of the possible branch targets; that is, label X can reach label Y if, starting execution from label X, it is possible to end up executing label Y along some possible path of execution.
We also call this the \textbf{Reachability} of a label.

\subsection{The algorithm}

The following is a broad overview of the steps of the Relooper algorithm. Some of the technical subtleties are described afterwards.

Given a set of labels, and a subset of those labels that are entries, try the following steps. Once one of the steps matches and creates a block, stop trying subsequent options.

\begin{enumerate}[label=\boxed{\arabic*}]
\item % (1)
For each label in the set, calculate which other labels it can reach.

\item
If we have only one entry, and execution can't return to it (i.e.\ if the single entry can't reach itself), then create a Simple block.
\begin{itemize}
\item
Put the single entry as the Internal label.
\item
Construct the Next block from all the other labels using this algorithm recursively.
The entries for the Next block are all the possible branch targets of the Internal label.
\end{itemize}

\item\label{relooper step: create loop block}
If execution can return to all the entries, create a Loop block.
\begin{itemize}
\item That is, take the union of the reachability of all the entries, and check whether all of the entries appear in that set.
\item Construct the Inner block from all the labels that can reach at least one of the entries.
The entries for the Inner block are the same as the current entries.
\item Construct the Next block from all the other labels.
The entries for the Next block are all the possible branch targets of labels in the Inner block that are labels in the Next block.
\end{itemize}

\item
If there's more than one entry, try to create a Multiple block. (Note that creating a Multiple block may not be possible.)

\begin{itemize}
\item For every entry, see if there are any labels it reaches that no other entry reaches. (This could be just the entry label itself.)

If at least one entry has such labels that it uniquely reaches, we can create a Multiple block.
\item Create one Handled block for every entry that uniquely reaches some labels.
Construct the Handled block from all the labels the entry uniquely reaches (including itself). The entry for that block is the entry we generated it from.
\item Construct the Next block from all the other labels. The entries for the Next block are all the entries we didn't convert into Handled blocks, plus any other possible branch targets out of the Handled blocks.
\end{itemize}

\item
If creating a Multiple block failed, create a Loop block, in the same way as step~\ref{relooper step: create loop block}.

\begin{itemize}
\item The Emscripten paper contains a proof of why this is possible \cite[10]{emscripten}.
I won't repeat it here, but the essence is that we can prove that (1) the algorithm is successful whenever it completes; (2) the algorithm must complete, because the problem is simplified at every step when we create a block; and (3) the algorithm is always able to create a block from the labels it's given.
\end{itemize}

\end{enumerate}


When Relooper is generating the output blocks, it processes and replaces the branch instructions in the input labels.
The instructions in the output blocks don't contain any of the original branch instructions.

\begin{itemize}
\item When creating a loop, any branch instructions to the start of the loop are replaced with a \texttt{continue}, and any branch instructions to outside the loop (i.e.\ to the Next block) are replaced with \texttt{break} instructions. These store the ID of the loop they act on, because loops may be nested.

\item When creating a Handled block, any branch instructions to the Next block are replaced with an \texttt{EndHandled} instruction. (Functionally this is identical to a \texttt{break}, but I chose to keep the two distinct from each other, so that \texttt{break} instructions can store the ID of the loop they jump out of, and \texttt{EndHandled} instructions can store the ID of the Multiple block.)

\item In addition to replacing branch instructions as above, every branch instruction will set the label variable.
The label variable is the mechanism for directing control flow in the generated code.
Where there was a \texttt{goto X} instruction in the input, this is replaced with a \texttt{label = X} instruction.

Whenever there is a choice of which block to enter, i.e.\ when entering a Multiple block, we insert instructions that check the value of the label variable, and execute the corresponding block.
Essentially, this acts like a switch statement.
\end{itemize}

This will generate some overhead, however most of the set/check label instructions will be able to be optimised away, for example for Simple blocks where execution just passes straight to the next block unconditionally.

\printbibliography

\end{document}
