\documentclass[10pt,a4paper]{article}

\usepackage{mrw}

\pagestyle{fancy}
\setlength{\headheight}{22.59pt}
\addtolength{\topmargin}{-10.59pt}
\fancyhead[L]{\textbf{Martin Walls}\\mrw64@cam.ac.uk}
\fancyhead[R]{\textbf{WebAssembly Research}\\Part II Project}
\fancyfoot[C]{\thepage\ / \pageref{LastPage}}

\usepackage{multirow}
\usepackage{tabularx}
\usepackage{xltabular}
\usepackage{booktabs}
\usepackage{hyperref}

\begin{document}

The byte values for each instruction in the binary format are listed at \url{https://webassembly.github.io/spec/core/binary/instructions.html}.

\section*{Values}

WebAssembly has the following types of values:

\begin{tabularx}{\textwidth}{l>{\ttfamily}llX}
\toprule
\textbf{Type} & \normalfont\textbf{Constructor} & \textbf{Bit width} & \textbf{Notes} \\
\midrule
Integer & i32 & 32-bit & Also used to store booleans and memory addresses. \\
& i64 & 64-bit \\
Float\footnote{Specified by IEEE 754-2019 (\url{https://ieeexplore.ieee.org/document/8766229})} & f32 & 32-bit \\
& f64 & 64-bit \\
Vector & v128 & 128-bit & Can store floats (4 32-bit, or 2 64-bit) or integers (2 64-bit, 4 32-bit, 8 16-bit, or 16 8-bit). \\
References & & Opaque & Pointers to various types of entities \\
\bottomrule
\end{tabularx}

Integers are interpreted as signed or unsigned numbers, depending on the operations applied to them.

But the spec also says there are (1) unsigned, (2) signed, and (3) uninterpreted integers? (structure>values)

\subsubsection*{Integer encoding}

Integers $n$ are encoded in the binary format using a variable-length integer encoding.


\section*{Numeric Instructions}

\textsf{ixx} and \textsf{fxx} represent instructions that exist for both 32-bit and 64-bit values. Instructions ending in \textsf{\_u} are unsigned operations that have an equivalent signed operation ending in \textsf{\_s}.

For binary instructions on the stack, the first operand is always the one that was pushed to the stack first, and th second operand is the one pushed to the stack last. For example,
\begin{lstlisting}[style=code, language=python]
i64.const 10  # first operand
i64.const 2   # second operand
i64.sub
\end{lstlisting}
will do the operation 10 - 2.

\begin{xltabular}{\textwidth}{l>{\sffamily}lX}
\toprule
Const
& ixx.const $n$ & Creates a constant value of specified type. \\
& fxx.const $z$ & \\
\midrule
\addlinespace
Comparison
& ixx.eqz & Equal to zero \textit{(no floating-point type equivalent)} \\
& ixx.eq & Equality \\
& ixx.ne & Not equal \\
& ixx.lt\_u & Less than \\
& ixx.gt\_u & Greater than \\
& ixx.le\_u & Less than or equal \\
& ixx.ge\_u & Greater than or equal \\
\addlinespace
\multicolumn{3}{X}{\itshape Equivalent float comparison operators exist, for \textsf{f32} and \textsf{f64} respectively, with the difference of not having signed/unsigned variants. For example, the less than operator \textsf{f64.lt}.} \\
\midrule
Unary operations
& ixx.clz & Count leading zeros \\
& ixx.ctz & Count trailing zeros \\
& ixx.popcnt & Count the number of bits set to 1 (population count) \\
\midrule
Arithmetic operations
& ixx.add & Addition \\
& ixx.sub & Subtraction \\
& ixx.mul & Multiplication \\
& ixx.div\_u & Division \\
& ixx.rem\_u & Remainder \\
\midrule
Bitwise operations
& ixx.and & Bitwise AND \\
& ixx.or & Bitwise OR \\
& ixx.xor & Bitwise XOR \\
& ixx.shl & Bitwise left-shift \\
& ixx.shr\_u & Bitwise right-shift. This operator is signed/unsigned because of sign extension. \\
& ixx.rotl & Bitwise left-rotate \\
& ixx.rotr & Bitwise right-rotate \\
\midrule
Floating-point specific
& fxx.min & Minimum of two numbers \\
& fxx.max & Maximum of two numbers \\
& fxx.copysign & Copy the sign bit from the second operand to the first operand \\
& fxx.abs & Absolute value \\
& fxx.neg & Negate \\
& fxx.sqrt & Square root \\
& fxx.ceil & Ceiling function \\
& fxx.floor & Floor function \\
& fxx.trunc & Truncate (discard everything after the decimal point). For negative numbers, \textsf{floor} will round down whereas \textsf{trunc} will round up. \\
& fxx.nearest & Round to the nearest integer \\
\midrule
Conversion
& i32.wrap\_i64 & Reduce an \textsf{i64} to an \textsf{i32}, taking just the lower 32 bits (i.e.\ taking it modulo $2^{32}$) \\
& i64.extend\_i32\_u & Sign-extend from an \textsf{i32} to an \textsf{i64} \\
& ixx.trunc\_fxx\_u & Truncate a float to an integer. Available for every combination of 32/64-bit and signed/unsigned. \\
& f32.demote\_f64 & Convert a \textsf{f64} to a \textsf{f32}. Unlike the integer wrap instruction, this will lose precision but not change the value of the number to an entirely different number. \\
& f64.promote\_f32 & Convert a \textsf{f32} to a \textsf{f64} \\
& fxx.convert\_ixx\_u & Convert an integer to a floating-point. Available for every combination of 32/64-bit and signed/unsigned. \\
& ixx.reinterpret\_fxx & Reinterpret the bits of a float as an integer. \\
& fxx.reinterpret\_ixx & Reinterpret the bits of an integer as a float. \\
\bottomrule
\end{xltabular}

\section*{Variable instructions}

These instructions are for getting/setting local and global variables.

Local variables are declared in function definitions, and global variables are declared in module definitions.

\begin{xltabular}{\textwidth}{>{\sffamily}lX}
\toprule
local.get $x$ & Get the value of the variable $x$ and put it on the stack \\
local.set $x$ & Set the value of the variable $x$ to the value on top of the stack (and remove it from the stack) \\
local.tee $x$ & The same as \textsf{local.set}, but also leaves the value on the stack \\
global.get $x$ & Same as \textsf{local.get} for a global variable \\
global.set $x$ & Same as \textsf{local.set} for a global variable \\
\bottomrule
\end{xltabular}

\section*{Control flow instructions}

Here, `$\ldots$' represents any sequence of instructions. Labels can also be omitted, in which case blocks/loops are implicitly labelled by their nesting depth.

\begin{xltabular}{\textwidth}{>{\sffamily}lX}
\toprule
block \normalfont\textit{\$label} $\ldots$ end & Creates a block that can be branched out of using a \textsf{br} instruction. The label is used to identify which block to branch out of. This treats \textsf{br} like a \texttt{break} statement in C. \\
loop \normalfont\textit{\$label} $\ldots$ end & Effectively the opposite of \textsf{block}. \textsf{loop} creates a `block' that can be branched to the beginning of. It doesn't loop by itself, it needs a \textsf{br} instruction inside the loop to go back to the start of the loop each iteration. This treats \textsf{br} like a \texttt{continue} statement in C. \\
if $\ldots$ else $\ldots$ end & Executes the first statement if the top value on the stack is true (positive), and the second statement if the top of the stack is false (0). \\
br \normalfont\textit{\$label} & Unconditionally branches. If \textit{\$label} refers to a block, it jumps to the end of the block. If \textit{\$label} refers to a loop, it jumps to the start of the loop. \\
br\_if \normalfont\textit{\$label} & Conditional branch \\
return & Returns from a function. If the stack is empty, nothing is returned. If the stack contains at least as many values as the function's return type signature specifies, those values are returned from the top of the stack, and any other values below them on the stack are discarded. \\
call \normalfont\textit{\$funcidx} & Calls a function. \\
call\_indirect \normalfont\textit{\$tableidx \$typeidx} & Calls a function from a table. \textit{\$typeidx} must be \textsf{funcref}. \\
nop & Does nothing. \\
unreachable & Marks a point in code that should be unreachable. If this instruction is executed, it unconditionally traps. (Similar to a failed assertion in C.) \\
select & Chooses between its first two operands, depending on if the third operand is zero (selects the second operand) or not (chooses the first operand). \\
drop & Pops the top value from the stack and immediately discards it. \\
\bottomrule
\end{xltabular}

\section*{Memory instructions}

\begin{xltabular}{\textwidth}{>{\sffamily}lX}
\toprule
ixx.load & Load an integer from memory, at the address given by the top of the stack. \\
fxx.load & Load a float from memory. \\
\addlinespace
ixx.load8\_u & \multirow[t]{3}{\hsize}{Integer loads can specify a smaller bit-width to load. Signed and unsigned instructions exist, to specify how to sign-extend the number.} \\
ixx.load16\_u & \\
i64.load32\_u & \\
\midrule
ixx.store & Store the second operand at the memory offset given by the first operand. \\
fxx.store & \\
ixx.store8 & Integer stores can specify a smaller bit-width to store in that location. \\
ixx.store16 \\
i64.store32 \\
\midrule
memory.grow & Grow the memory by the number of pages given by the operand. \\
memory.size & Get the number of pages the memory currently has. \\
memory.fill & Set all the bytes in the specified region to a given byte. \\
memory.copy & Copy data from one memory region to another (can be overlapping). \\
memory.init & Copy data from a passive data segment into memory. \\
data.drop & Prevent any further use of a passive data segment (allows the memory used by it to be freed). \\
\bottomrule
\end{xltabular}

\subsection*{Data segments}

Initially, the program's memory is filled with zero bytes. Data segments exist to allow memory to be initialised from static bytes.

Data segments can either be passive or active. Passive data segments are loaded into memory explicitly using the \textsf{memory.init} instruction. Active data segments are automatically copied into memory when the program loads. Active data segments specify the offset where they'll be loaded.

\section*{Tables}

A table is an array of function pointers, that can be used to indirectly call functions. Tables live outside of WebAssembly's memory, so they can't be seen from the program itself. This keeps the memory addresses of functions hidden. To call a function referenced in a table, the \textsf{call\_indirect} instruction is used.

\section*{Modules}

\end{document}
