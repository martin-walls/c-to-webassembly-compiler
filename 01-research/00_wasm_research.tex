\documentclass[10pt,a4paper]{article}

\usepackage[bigmarginright]{mrw}

\pagestyle{fancy}
\setlength{\headheight}{22.59pt}
\addtolength{\topmargin}{-10.59pt}
\fancyhead[L]{\textbf{Martin Walls}\\mrw64@cam.ac.uk}
\fancyhead[R]{\textbf{WebAssembly Research}\\Part II Project}
\fancyfoot[C]{\thepage\ / \pageref{LastPage}}

\usepackage{multirow}
\usepackage{tabularx}
\usepackage{xltabular}
\usepackage{booktabs}
\usepackage{hyperref}

\newcommand{\hex}[1]{\texttt{#1}}
\newcommand{\instr}[1]{\textsf{#1}}

\begin{document}


The byte values for each instruction in the binary format are listed at \url{https://webassembly.github.io/spec/core/binary/instructions.html}.

\section*{Values}

WebAssembly has the following types of values:

\begin{tabularx}{\textwidth}{l>{\sffamily}llX}
\toprule
\textbf{Type} & \normalfont\textbf{Constructor} & \textbf{Bit width} & \textbf{Notes} \\
\midrule
Integer & i32 & 32-bit & Also used to store booleans and memory addresses. \\
& i64 & 64-bit \\
Float\footnote{Specified by IEEE 754-2019 (\url{https://ieeexplore.ieee.org/document/8766229})} & f32 & 32-bit \\
& f64 & 64-bit \\
Vector & v128 & 128-bit & Can store floats (4 32-bit, or 2 64-bit) or integers (2 64-bit, 4 32-bit, 8 16-bit, or 16 8-bit). \\
References & funcref & Opaque & Pointers to functions, of any type \\
& externref & & Pointers to other types of objects that can be passed into WebAssembly \\
\bottomrule
\end{tabularx}

Integers are interpreted as signed or unsigned numbers, depending on the operations applied to them.
\marginpar{\raggedright But the spec also says there are (1) unsigned, (2) signed, and (3) uninterpreted integers? (docs>structure>values)}

\subsubsection*{Integer encoding}

Integers $n$ are encoded in the binary format using a variable-length integer encoding.


\section*{Numeric Instructions}

\textsf{ixx} and \textsf{fxx} represent instructions that exist for both 32-bit and 64-bit values. Instructions ending in \textsf{\_u} are unsigned operations that have an equivalent signed operation ending in \textsf{\_s}.

For binary instructions on the stack, the first operand is always the one that was pushed to the stack first, and th second operand is the one pushed to the stack last. For example,
\begin{lstlisting}[style=code, language=python]
i64.const 10  # first operand
i64.const 2   # second operand
i64.sub
\end{lstlisting}
will do the operation 10 - 2.

\begin{xltabular}{\textwidth}{l>{\sffamily}lX}
\toprule
Const
& ixx.const $n$ & Creates a constant value of specified type. \\
& fxx.const $z$ & \\
\midrule
\addlinespace
Comparison
& ixx.eqz & Equal to zero \textit{(no floating-point type equivalent)} \\
& ixx.eq & Equality \\
& ixx.ne & Not equal \\
& ixx.lt\_u & Less than \\
& ixx.gt\_u & Greater than \\
& ixx.le\_u & Less than or equal \\
& ixx.ge\_u & Greater than or equal \\
\addlinespace
\multicolumn{3}{X}{\itshape Equivalent float comparison operators exist, for \textsf{f32} and \textsf{f64} respectively, with the difference of not having signed/unsigned variants. For example, the less than operator \textsf{f64.lt}.} \\
\midrule
Unary operations
& ixx.clz & Count leading zeros \\
& ixx.ctz & Count trailing zeros \\
& ixx.popcnt & Count the number of bits set to 1 (population count) \\
\midrule
Arithmetic operations
& ixx.add & Addition \\
& ixx.sub & Subtraction \\
& ixx.mul & Multiplication \\
& ixx.div\_u & Division \\
& ixx.rem\_u & Remainder \\
\midrule
Bitwise operations
& ixx.and & Bitwise AND \\
& ixx.or & Bitwise OR \\
& ixx.xor & Bitwise XOR \\
& ixx.shl & Bitwise left-shift \\
& ixx.shr\_u & Bitwise right-shift. This operator is signed/unsigned because of sign extension. \\
& ixx.rotl & Bitwise left-rotate \\
& ixx.rotr & Bitwise right-rotate \\
\midrule
Floating-point specific
& fxx.min & Minimum of two numbers \\
& fxx.max & Maximum of two numbers \\
& fxx.copysign & Copy the sign bit from the second operand to the first operand \\
& fxx.abs & Absolute value \\
& fxx.neg & Negate \\
& fxx.sqrt & Square root \\
& fxx.ceil & Ceiling function \\
& fxx.floor & Floor function \\
& fxx.trunc & Truncate (discard everything after the decimal point). For negative numbers, \textsf{floor} will round down whereas \textsf{trunc} will round up. \\
& fxx.nearest & Round to the nearest integer \\
\midrule
Conversion
& i32.wrap\_i64 & Reduce an \textsf{i64} to an \textsf{i32}, taking just the lower 32 bits (i.e.\ taking it modulo $2^{32}$) \\
& i64.extend\_i32\_u & Sign-extend from an \textsf{i32} to an \textsf{i64} \\
& ixx.trunc\_fxx\_u & Truncate a float to an integer. Available for every combination of 32/64-bit and signed/unsigned. \\
& f32.demote\_f64 & Convert a \textsf{f64} to a \textsf{f32}. Unlike the integer wrap instruction, this will lose precision but not change the value of the number to an entirely different number. \\
& f64.promote\_f32 & Convert a \textsf{f32} to a \textsf{f64} \\
& fxx.convert\_ixx\_u & Convert an integer to a floating-point. Available for every combination of 32/64-bit and signed/unsigned. \\
& ixx.reinterpret\_fxx & Reinterpret the bits of a float as an integer. \\
& fxx.reinterpret\_ixx & Reinterpret the bits of an integer as a float. \\
\bottomrule
\end{xltabular}

\section*{Variable instructions}

These instructions are for getting/setting local and global variables.

Local variables are declared in function definitions, and global variables are declared in module definitions.

\begin{xltabular}{\textwidth}{>{\sffamily}lX}
\toprule
local.get $x$ & Get the value of the variable $x$ and put it on the stack \\
local.set $x$ & Set the value of the variable $x$ to the value on top of the stack (and remove it from the stack) \\
local.tee $x$ & The same as \textsf{local.set}, but also leaves the value on the stack \\
global.get $x$ & Same as \textsf{local.get} for a global variable \\
global.set $x$ & Same as \textsf{local.set} for a global variable \\
\bottomrule
\end{xltabular}

\section*{Control flow instructions}

Here, `$\ldots$' represents any sequence of instructions. Labels can also be omitted, in which case blocks/loops are implicitly labelled by their nesting depth.

\marginpar{labels vs implicitly referencing by depth?}

\begin{xltabular}{\textwidth}{>{\sffamily}lX}
\toprule
block \normalfont\textit{\$label} $\ldots$ end & Creates a block that can be branched out of using a \textsf{br} instruction. The label is used to identify which block to branch out of. This treats \textsf{br} like a \texttt{break} statement in C. \\
loop \normalfont\textit{\$label} $\ldots$ end & Effectively the opposite of \textsf{block}. \textsf{loop} creates a `block' that can be branched to the beginning of. It doesn't loop by itself, it needs a \textsf{br} instruction inside the loop to go back to the start of the loop each iteration. This treats \textsf{br} like a \texttt{continue} statement in C. \\
if $\ldots$ else $\ldots$ end & Executes the first statement if the top value on the stack is true (positive), and the second statement if the top of the stack is false (0). \\
br \normalfont\textit{\$label} & Unconditionally branches. If \textit{\$label} refers to a block, it jumps to the end of the block. If \textit{\$label} refers to a loop, it jumps to the start of the loop. \\
br\_if \normalfont\textit{\$label} & Conditional branch \\
return & Returns from a function. If the stack is empty, nothing is returned. If the stack contains at least as many values as the function's return type signature specifies, those values are returned from the top of the stack, and any other values below them on the stack are discarded. \\
call \normalfont\textit{\$funcidx} & Calls a function. \\
call\_indirect \normalfont\textit{\$tableidx \$typeidx} & Calls a function from a table. \textit{\$typeidx} must be \textsf{funcref}. \\
nop & Does nothing. \\
unreachable & Marks a point in code that should be unreachable. If this instruction is executed, it unconditionally traps. (Similar to a failed assertion in C.) \\
select & Chooses between its first two operands, depending on if the third operand is zero (selects the second operand) or not (chooses the first operand). \\
drop & Pops the top value from the stack and immediately discards it. \\
\bottomrule
\end{xltabular}

\section*{Memory instructions}

\begin{xltabular}{\textwidth}{>{\sffamily}lX}
\toprule
ixx.load & Load an integer from memory, at the address given by the top of the stack. \\
fxx.load & Load a float from memory. \\
\addlinespace
ixx.load8\_u & \multirow[t]{3}{\hsize}{Integer loads can specify a smaller bit-width to load. Signed and unsigned instructions exist, to specify how to sign-extend the number.} \\
ixx.load16\_u & \\
i64.load32\_u & \\
\midrule
ixx.store & Store the second operand at the memory offset given by the first operand. \\
fxx.store & \\
ixx.store8 & Integer stores can specify a smaller bit-width to store in that location. \\
ixx.store16 \\
i64.store32 \\
\midrule
memory.grow & Grow the memory by the number of pages given by the operand. \\
memory.size & Get the number of pages the memory currently has. \\
memory.fill & Set all the bytes in the specified region to a given byte. \\
memory.copy & Copy data from one memory region to another (can be overlapping). \\
memory.init & Copy data from a passive data segment into memory. \\
data.drop & Prevent any further use of a passive data segment (allows the memory used by it to be freed). \\
\bottomrule
\end{xltabular}

\subsection*{Data segments}

Initially, the program's memory is filled with zero bytes. Data segments exist to allow memory to be initialised from static bytes.

Data segments can either be passive or active. Passive data segments are loaded into memory explicitly using the \textsf{memory.init} instruction. Active data segments are automatically copied into memory when the program loads. Active data segments specify the offset where they'll be loaded.

\section*{Tables}

A table is an array of function pointers, that can be used to indirectly call functions. Tables live outside of WebAssembly's memory, so they can't be seen from the program itself. This keeps the memory addresses of functions hidden. To call a function referenced in a table, the \textsf{call\_indirect} instruction is used.

\section*{Modules}

\newcommand{\codedescription}[1]{\textit{\small#1}}

A module is a compilation and loading unit for a WebAssembly program.
All Wasm programs are organised into a module.

Modules define the different parts of the program.
Modules are split up into sections, which each start with a section ID, the size of the section in bytes, followed by the section contents. Each section is optional, leaving a section out is equivalent to including it and leaving it empty.

To show how modules work, I've used the \texttt{wat2wasm} tool to view the generated binary for the following Wasm program:

\lstinputlisting[style=codenumbered, frame=shadowbox]{53-module-deconstr.wat}

\subsection*{Preamble}

A Wasm binary always starts with an 8-byte preamble. This contains a 4-byte magic number (the string `\texttt{\textbackslash0asm}'), and a WebAssembly version number. The current version number is 1; it could be incremented in future if breaking changes are implemented.

\lstinputlisting[style=code, firstline=1, lastline=2, frame=shadowbox]{53-module-deconstr.module.txt}


\subsection*{Types section}

The section starts with the section code to identify the section, then the size of the section in bytes. The size refers to everything in the section apart from the code and size, so here \texttt{0x10} = 16 bytes.

\lstinputlisting[style=code, firstline=3, lastline=5, frame=shadowbox]{53-module-deconstr.module.txt}

The types section defines the types of all the functions in the module (including imported functions).
If multiple functions have the same type, it will only be defined once here; each function specifies which index type it has.

The next byte says how many types are defined here.

\lstinputlisting[style=code, firstline=6, lastline=6, frame=shadowbox]{53-module-deconstr.module.txt}

The rest of the section is a vector of the function types, that is, just a list of the types after one another.
Each function type is identified by the starting byte \texttt{0x60}.

The next byte is the number of function parameters, followed by a byte encoding the type of each parameter. Here, \texttt{0x7f} is the code for an \textsf{i32}.

The result type is encoded in the same way; a count followed by a byte for each result type (functions can have either 0 or 1 return value, currently).

Types are referred to by an index starting from 0.


\codedescription{Type definition for the explicitly defined type (\texttt{\$addtype}):}
\lstinputlisting[style=code, firstline=7, lastline=13, frame=shadowbox]{53-module-deconstr.module.txt}

\codedescription{Type definition for the imported function (\texttt{\$log}):}
\lstinputlisting[style=code, firstline=14, lastline=18, frame=shadowbox]{53-module-deconstr.module.txt}

\codedescription{Type definition for \texttt{\$main}:}
\lstinputlisting[style=code, firstline=19, lastline=24, frame=shadowbox]{53-module-deconstr.module.txt}

\codedescription{Type definition for the \texttt{\$startfunc}:}
\lstinputlisting[style=code, firstline=25, lastline=28, frame=shadowbox]{53-module-deconstr.module.txt}


\subsection*{Imports}

The imports section defines all the imports to the module.

\lstinputlisting[style=code, firstline=29, lastline=32, frame=shadowbox]{53-module-deconstr.module.txt}

In this program, there's only one import, the \texttt{console.log} function. Wasm imports are defined by a two-level hierarchy, a module name and a field name. These are stored at strings, preceded by a byte specifying their length.

The \textit{import kind} byte specifies what type of import this is. \texttt{0x00} defines this as a function import. Other types are \texttt{0x01} for tables, \texttt{0x02} for memory, and \texttt{0x03} for globals. The following byte, in the case of functions, specifies which type (indexed from zero) this function has.

\codedescription{Import definition on line 2:}
\lstinputlisting[style=code, firstline=33, lastline=39, frame=shadowbox]{53-module-deconstr.module.txt}


\subsection*{Functions}

The functions section maps between function definitions and their types. For each function index, it specifies the index of the type defined in the types section that matches that function's type.

(Imported functions aren't included here, their type is specified in the imports section.)

\lstinputlisting[style=code, firstline=40, lastline=42, frame=shadowbox]{53-module-deconstr.module.txt}

The body of this section first gives the number of functions, then the index of each function's type, starting at function index 0 and increasing consecutively. (These indexes point to the definitions in the types section.)

\lstinputlisting[style=code, firstline=43, lastline=46, frame=shadowbox]{53-module-deconstr.module.txt}


\subsection*{Tables}

The tables section contains a vector of all the tables defined in the module.

\lstinputlisting[style=code, firstline=47, lastline=50, frame=shadowbox]{53-module-deconstr.module.txt}

Each table is encoded with the type it stores as the first byte (\textsf{funcref} or \textsf{externref}), followed by the size limits. If the limits flag is \hex{0x01}, then the minimum and maximum are specified, if it's \hex{0x00} then no maximum is given. In this example, only a minimum is specified, and the \hex{0x10} corresponds to the table size of 16 that we set on line 25.

\lstinputlisting[style=code, firstline=51, lastline=54, frame=shadowbox]{53-module-deconstr.module.txt}


\subsection*{Memory}

The memory section is very similar to the table section. It contains a vector of the memories defined in the module. (In the current WebAssembly version, only a single memory can be defined.)

\lstinputlisting[style=code, firstline=55, lastline=58, frame=shadowbox]{53-module-deconstr.module.txt}

Each memory is specified by its size limits (in units of page size), in the same way as tables above.

\lstinputlisting[style=code, firstline=59, lastline=61, frame=shadowbox]{53-module-deconstr.module.txt}


\subsection*{Globals}

The globals section contains a vector of all the global variables in the module and how they're initialised. Globals are initialised by a constant expression.

\lstinputlisting[style=code, firstline=62, lastline=65, frame=shadowbox]{53-module-deconstr.module.txt}

Each global starts by specifying its type. The first byte gives the value type (here \instr{i32}), and then its mutability. \hex{0x00} is an immutable global, and \hex{0x01} is a mutable global.

\lstinputlisting[style=code, firstline=66, lastline=67, frame=shadowbox]{53-module-deconstr.module.txt}

After the type is the initialiser expression for the global, which must be a constant expression. Here, the constant expression \instr{(i32.const 42)} is represented.

\lstinputlisting[style=code, firstline=68, lastline=70, frame=shadowbox]{53-module-deconstr.module.txt}


\subsection*{Exports}

The exports section defines all the exports from the module.

\lstinputlisting[style=code, firstline=71, lastline=74, frame=shadowbox]{53-module-deconstr.module.txt}

Each export starts with a string, specifying its name.

After the name is a flag to specify the type of export.
\hex{0x00} is a function export, \hex{0x01} is a table export, \hex{0x02} is a memory export, and \hex{0x03} is a global export.
After the flag, the index of the respective entity to export is given.

\codedescription{\ttfamily (export "main" (func \$main))}
\lstinputlisting[style=code, firstline=75, lastline=78, frame=shadowbox]{53-module-deconstr.module.txt}

\codedescription{\ttfamily (export "memory" (memory 0))}
\lstinputlisting[style=code, firstline=79, lastline=82, frame=shadowbox]{53-module-deconstr.module.txt}


\subsection*{Start}

The start section specifies an optional function that should be run automatically when the module is initialised.
This could be used, for example, to initialised a global variable to a non-constant expression.

The section contains a single function index to specify the function to run.

\lstinputlisting[style=code, firstline=83, lastline=86, frame=shadowbox]{53-module-deconstr.module.txt}


\subsection*{Element}

Element segments are used to statically initialise the contents of tables.

\lstinputlisting[style=code, firstline=87, lastline=90, frame=shadowbox]{53-module-deconstr.module.txt}

Each element segment starts with a flag (\hex{0x00}--\hex{0x07}) that specifies the mode of the element and the binary structure of this segment. In this case of flag \hex{0x00}, the element segment is active (it gets automatically initialised to its table during instantiation), and the element automatically belongs to table 0.

Following the flag is a constant expression that specifies the offset into the table, which is where the elements will be stored.

After this come the actual elements themselves, each being a function index.

\lstinputlisting[style=code, firstline=91, lastline=97, frame=shadowbox]{53-module-deconstr.module.txt}


\subsection*{Data count}

The data count section is an optional section used by single-pass validators. Because the data section comes after the code section, a validator could only check if instructions that reference data indexes (\instr{memory.init}, \instr{data.drop}) are valid until it's read the data section, at which point it would have to go back to the code section again. The data count section helps by storing the number of data segments before the code section, so a validator doesn't have to defer validation.

\lstinputlisting[style=code, firstline=98, lastline=101, frame=shadowbox]{53-module-deconstr.module.txt}


\subsection*{Code}

The code section contains the bodies of all the functions of the program.

\lstinputlisting[style=code, firstline=102, lastline=105, frame=shadowbox]{53-module-deconstr.module.txt}

Each entry in the code section is the code for one function.
It starts by specifying the size (in bytes) of the function code.

Next is the declaration of any local variables, starting with the number of declarations. Each declaration is a pair of a count and a type, which specifies that many local variables of that type.

The function body code follows this as an expression; that is, a sequence of instructions terminated by an \instr{end} instruction.

\codedescription{\texttt{func \$main}}
\lstinputlisting[style=code, firstline=106, lastline=120, frame=shadowbox]{53-module-deconstr.module.txt}
\codedescription{\texttt{func \$add}}
\lstinputlisting[style=code, firstline=121, lastline=129, frame=shadowbox]{53-module-deconstr.module.txt}
\codedescription{\texttt{func \$startfunc}}
\lstinputlisting[style=code, firstline=130, lastline=137, frame=shadowbox]{53-module-deconstr.module.txt}


\subsection*{Data}

Data segments are used to statically initialise the contents of memory.

\lstinputlisting[style=code, firstline=138, lastline=141, frame=shadowbox]{53-module-deconstr.module.txt}

Each segment starts with a flag to specify the mode, and structure of this segment. Flag \hex{0x00} is an active data segment, which automatically references memory 0. Flat \hex{0x01} is a passive data segment, which needs to be explicitly initialised into memory with the \instr{memory.init} instruction. Flag \hex{0x02} is an active data segment, where the memory index is also explicitly defined. (In the current Wasm version, at most one memory is allowed, so there's no real use for this yet.)
The flag can be interpreted as a bit field, where bit 0 (least significant) being present indicates the segment being passive, and bit 1 indicates the memory index being explicitly defined.

This is followed by a constant initialiser expression that specifies the offset into the memory to store the data at.

\lstinputlisting[style=code, firstline=142, lastline=146, frame=shadowbox]{53-module-deconstr.module.txt}

The remainder of the segment is the actual data itself.

\lstinputlisting[style=code, firstline=147, lastline=149, frame=shadowbox]{53-module-deconstr.module.txt}

\section*{Strings and \texttt{printf}}

Wasm doesn't have any concept of a `string'; it can only handle integers and floats. However, since Wasm has linear memory of bytes, we can store strings as an array of their character values, terminated with a \texttt{0} (the null character), like in C.

This will work fine for string manipulation in Wasm programs. However, printing a string to console, for example, is more complicated, because this has to be done by calling a function imported from the calling environment (i.e.\ from JavaScript).

\marginpar{How do I handle this when I write the compiler - do I need to provide a specification for the functions the JS is required to import to Wasm?}

Wasm functions take a fixed number of arguments, of the defined value types. When we import a function from JavaScript, we have to also define it's function signature in Wasm. Therefore if we simply import the \texttt{console.log()} function directly, we have to give it a fixed number of numeric arguments. This would allow us to print single numbers to console, but doesn't help us print strings.

To print strings, we have to share the Wasm memory with the JavaScript (by exporting it), and then write a function that takes an index into the memory, reads a null-terminated string from there one byte at a time, and then prints the resulting string. This function can then be imported into Wasm, and used as a \texttt{printf} function, by passing a pointer to the string to print.

Handling user input from stdin would require a similar function import, that uses JavaScript to take user input and write the string into Wasm memory, returning the index back to Wasm.


\end{document}
